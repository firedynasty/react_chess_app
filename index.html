<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Analyzer - Stockfish.js</title>
    <!-- Chessboard.js CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        h1 {
            color: #00d4ff;
            text-align: center;
        }
        .status-bar {
            background: #16213e;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff6b6b;
        }
        .status-dot.ready {
            background: #51cf66;
        }
        .status-dot.working {
            background: #ffd43b;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        @media (max-width: 800px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
        .panel {
            background: #16213e;
            padding: 20px;
            border-radius: 12px;
        }
        .panel h2 {
            margin-top: 0;
            color: #00d4ff;
            font-size: 1.2em;
            border-bottom: 1px solid #0f3460;
            padding-bottom: 10px;
        }
        textarea {
            width: 100%;
            height: 200px;
            background: #0f3460;
            border: 1px solid #1a1a2e;
            color: #eee;
            padding: 12px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
            resize: vertical;
        }
        textarea:focus {
            outline: none;
            border-color: #00d4ff;
        }
        input[type="text"] {
            width: 100%;
            background: #0f3460;
            border: 1px solid #1a1a2e;
            color: #eee;
            padding: 12px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
        }
        input[type="text"]:focus {
            outline: none;
            border-color: #00d4ff;
        }
        button {
            background: #00d4ff;
            color: #1a1a2e;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.2s;
        }
        button:hover {
            background: #00b8e6;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        .settings {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        .setting-group label {
            display: block;
            font-size: 12px;
            color: #888;
            margin-bottom: 4px;
        }
        .setting-group input, .setting-group select {
            width: 100%;
            background: #0f3460;
            border: 1px solid #1a1a2e;
            color: #eee;
            padding: 8px;
            border-radius: 6px;
        }
        .results {
            margin-top: 20px;
        }
        .result-item {
            background: #0f3460;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid #00d4ff;
        }
        .result-item.blunder {
            border-left-color: #ff6b6b;
        }
        .result-item.mistake {
            border-left-color: #ffa94d;
        }
        .result-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        .move-info {
            font-weight: bold;
        }
        .eval-change {
            font-family: monospace;
            color: #888;
        }
        .severity {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
        }
        .severity.blunder {
            background: #ff6b6b;
            color: #1a1a2e;
        }
        .severity.mistake {
            background: #ffa94d;
            color: #1a1a2e;
        }
        .fen-link {
            font-size: 12px;
            color: #00d4ff;
            text-decoration: none;
        }
        .fen-link:hover {
            text-decoration: underline;
        }
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #0f3460;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }
        .progress-fill {
            height: 100%;
            background: #00d4ff;
            width: 0%;
            transition: width 0.3s;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        .stat-box {
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
        }
        .stat-label {
            font-size: 12px;
            color: #888;
        }
        .stat-box.blunders .stat-value { color: #ff6b6b; }
        .stat-box.mistakes .stat-value { color: #ffa94d; }
        .stat-box.inaccuracies .stat-value { color: #51cf66; }
        #log {
            height: 150px;
            overflow-y: auto;
            font-size: 12px;
            background: #0a0a15;
            padding: 10px;
            border-radius: 8px;
            font-family: monospace;
        }
        .log-entry {
            margin-bottom: 4px;
            color: #888;
        }
        .log-entry.info { color: #00d4ff; }
        .log-entry.success { color: #51cf66; }
        .log-entry.error { color: #ff6b6b; }
        .log-entry.warning { color: #ffd43b; }

        /* Chess.com Import Styles */
        .chesscom-import-bar {
            background: #16213e;
            padding: 12px 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }
        .chesscom-import-bar label {
            color: #888;
            font-size: 13px;
        }
        .chesscom-import-bar input[type="text"] {
            background: #0f3460;
            border: 1px solid #1a1a2e;
            color: #eee;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            min-width: 180px;
        }
        .chesscom-import-bar input[type="text"]:focus {
            outline: none;
            border-color: #00d4ff;
        }
        .chesscom-import-bar input[type="text"]::placeholder {
            color: #666;
        }
        #fetch-games-btn {
            background: #0f3460;
            color: #00d4ff;
            border: 1px solid #00d4ff;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }
        #fetch-games-btn:hover {
            background: #00d4ff;
            color: #1a1a2e;
        }
        #fetch-games-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .num-games-select {
            background: #0f3460;
            border: 1px solid #1a1a2e;
            color: #eee;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
        }
        .num-games-select:focus {
            outline: none;
            border-color: #00d4ff;
        }
        .game-selection-container {
            background: #16213e;
            padding: 12px 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .game-selection-container label {
            display: block;
            color: #888;
            font-size: 12px;
            margin-bottom: 8px;
        }
        #game-dropdown {
            width: 100%;
            background: #0f3460;
            border: 1px solid #1a1a2e;
            color: #eee;
            padding: 10px 12px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
        }
        #game-dropdown:focus {
            outline: none;
            border-color: #00d4ff;
        }
        #game-details {
            margin-top: 12px;
            padding: 12px;
            background: #0f3460;
            border-radius: 6px;
            font-size: 13px;
            border-left: 3px solid #00d4ff;
        }
        #game-details p {
            margin: 4px 0;
            color: #ccc;
        }
        #game-details a {
            color: #00d4ff;
            text-decoration: none;
        }
        #game-details a:hover {
            text-decoration: underline;
        }
        .chesscom-message {
            padding: 10px 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 13px;
        }
        .chesscom-message.error {
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
            border: 1px solid #ff6b6b;
        }
        .chesscom-message.success {
            background: rgba(81, 207, 102, 0.2);
            color: #51cf66;
            border: 1px solid #51cf66;
        }
        .chesscom-message.info {
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
            border: 1px solid #00d4ff;
        }
        .chesscom-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #0f3460;
            border-top: 2px solid #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Drag-to-scroll toggle switch */
        .drag-scroll-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #0f3460;
            transition: .4s;
            border-radius: 26px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 4px;
            bottom: 4px;
            background-color: #888;
            transition: .4s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        input:checked + .slider {
            background: linear-gradient(135deg, #00d4ff 0%, #00b8e6 100%);
        }
        input:checked + .slider:before {
            transform: translateX(24px);
            background-color: white;
        }
        .toggle-label {
            font-size: 13px;
            color: #888;
            font-weight: 500;
        }
        .toggle-label.active {
            color: #00d4ff;
        }
        /* Markdown content styles for chat */
        .markdown-content {
            font-size: 14px;
        }
        .markdown-content p {
            margin: 0 0 10px 0;
        }
        .markdown-content p:last-child {
            margin-bottom: 0;
        }
        .markdown-content h1, .markdown-content h2, .markdown-content h3, .markdown-content h4 {
            margin: 16px 0 8px 0;
            color: #00d4ff;
        }
        .markdown-content h3 {
            font-size: 16px;
        }
        .markdown-content h4 {
            font-size: 14px;
        }
        .markdown-content strong {
            color: #fff;
            font-weight: 600;
        }
        .markdown-content em {
            font-style: italic;
        }
        .markdown-content ul, .markdown-content ol {
            margin: 8px 0;
            padding-left: 24px;
        }
        .markdown-content li {
            margin: 4px 0;
        }
        .markdown-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 12px 0;
            font-size: 13px;
        }
        .markdown-content table th,
        .markdown-content table td {
            border: 1px solid #444;
            padding: 8px 10px;
            text-align: left;
        }
        .markdown-content table th {
            background: #0f3460;
            color: #00d4ff;
            font-weight: 600;
        }
        .markdown-content table tr:nth-child(even) {
            background: rgba(15, 52, 96, 0.3);
        }
        .markdown-content code {
            background: #0f3460;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 13px;
        }
        .markdown-content pre {
            background: #0f3460;
            padding: 12px;
            border-radius: 6px;
            overflow-x: auto;
        }
        .markdown-content pre code {
            background: none;
            padding: 0;
        }
        .markdown-content blockquote {
            border-left: 3px solid #00d4ff;
            margin: 12px 0;
            padding-left: 12px;
            color: #aaa;
        }
        .markdown-content hr {
            border: none;
            border-top: 1px solid #444;
            margin: 16px 0;
        }
        /* Move Table Styles */
        .move-number {
            color: #888;
            margin-right: 2px;
        }
        .move-san {
            color: #eee;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            margin-right: 3px;
            display: inline;
        }
        .move-san:hover {
            background: #17a2b8;
            color: #fff;
        }
        .move-san.current {
            background: #00d4ff;
            color: #1a1a2e;
        }
        .move-san.main-line {
            font-weight: bold;
        }
        .variation-container {
            display: inline;
            color: #888;
            margin-left: 4px;
        }
        .variation-move {
            color: #aaa;
            cursor: pointer;
            padding: 1px 3px;
            border-radius: 2px;
            font-size: 12px;
        }
        .variation-move:hover {
            background: #6f42c1;
            color: #fff;
        }
        .variation-move.current {
            background: #9c27b0;
            color: #fff;
        }
    </style>
</head>
<body>
    <h1>Chess Game Analyzer</h1>
    <p style="text-align: center; color: #888;">Powered by Stockfish.js (runs in your browser - no server needed!)</p>

    <div class="status-bar" style="display: none;">
        <div class="status-indicator">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Loading Stockfish...</span>
        </div>
        <div id="engineInfo" style="color: #888; font-size: 12px;"></div>
    </div>

    <div class="status-bar">
        <a href="https://youtu.be/fwPcoDfQwyo" target="_blank" style="background: #0f3460; color: #00d4ff; padding: 8px 16px; border-radius: 4px; text-decoration: none; font-size: 14px;">Tutorial ‚Üó</a>
    </div>

    <!-- Chess.com Import Section -->
    <div class="chesscom-import-bar" id="chesscom-import-bar">
        <label for="chesscom-username">Chess.com:</label>
        <input type="text" id="chesscom-username" placeholder="Enter username" autocomplete="username">
        <button type="button" id="fetch-games-btn" onclick="fetchChesscomGames()">
            üì• Fetch Games
        </button>
        <select id="num-games" class="num-games-select">
            <option value="5" selected>5 games</option>
            <option value="10">10 games</option>
            <option value="15">15 games</option>
            <option value="20">20 games</option>
        </select>
    </div>

    <div class="game-selection-container" id="game-selection-container" style="display: none;">
        <label for="game-dropdown">Select a game to analyze:</label>
        <select id="game-dropdown" onchange="loadSelectedGame()">
            <option value="">-- Select a game --</option>
        </select>
        <div id="game-details"></div>
    </div>

    <!-- Stockfish Variation Adder -->
    <div id="variation-adder" style="display: none; background: #16213e; padding: 15px; border-radius: 8px; margin: 15px auto; max-width: 900px;">
        <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
            <label style="color: #00d4ff; font-size: 13px;">Add Variation at:</label>
            <input type="text" id="variation-move-input" placeholder="12. or 12..."
                style="width: 100px; padding: 8px; background: #0f3460; border: 1px solid #1a1a2e; color: #eee; border-radius: 6px;"
                onkeydown="if(event.key==='Enter')analyzeForVariation()">
            <button id="analyze-variation-btn" onclick="analyzeForVariation()"
                style="padding: 8px 15px; background: #0f3460; color: #00d4ff; border: 1px solid #00d4ff; border-radius: 6px; cursor: pointer;">
                Analyze
            </button>
            <select id="variation-depth" title="Depth" style="padding: 8px; background: #0f3460; border: 1px solid #1a1a2e; color: #eee; border-radius: 6px;">
                <option value="12">d12</option>
                <option value="14">d14</option>
                <option value="16" selected>d16</option>
                <option value="18">d18</option>
            </select>
            <span id="variation-status" style="color: #888; font-size: 12px;"></span>
        </div>
        <div id="variation-result" style="display: none; margin-top: 12px; padding: 12px; background: #0f3460; border-radius: 6px; border-left: 3px solid #27ae60;">
            <div id="variation-best-move" style="color: #27ae60; font-weight: bold; margin-bottom: 5px;"></div>
            <div id="variation-line" style="color: #ccc; font-family: monospace; font-size: 13px;"></div>
            <div style="margin-top: 10px; display: flex; gap: 10px;">
                <button id="add-variation-btn" onclick="addVariationToPgn()"
                    style="display: none; padding: 6px 12px; background: #27ae60; color: #fff; border: none; border-radius: 6px; cursor: pointer;">
                    Add to PGN
                </button>
                <button onclick="clearVariationResult()"
                    style="padding: 6px 12px; background: #333; color: #888; border: none; border-radius: 6px; cursor: pointer;">
                    Clear
                </button>
                <span style="color: #27ae60; font-size: 12px; margin-left: 10px;">added variation to pgn below</span>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="panel">
            <h2>Input</h2>

            <div class="settings">
                <div class="setting-group">
                    <label>Analysis Depth</label>
                    <select id="depth">
                        <option value="10">10 (Fast ~2s/move)</option>
                        <option value="12" selected>12 (Balanced ~4s/move)</option>
                        <option value="15">15 (Accurate ~8s/move)</option>
                        <option value="18">18 (Deep ~15s/move)</option>
                    </select>
                </div>
                <div class="setting-group">
                    <label>Engine Source</label>
                    <select id="engineSource">
                        <option value="lichess">Lichess Cloud (Fast)</option>
                        <option value="stockfish" selected>Stockfish.js (Client)</option>
                    </select>
                </div>
            </div>

            <label style="display: block; margin-bottom: 8px; color: #888; font-size: 12px;">
                Paste PGN or moves (e.g., 1. e4 e5 2. Nf3 Nc6)
            </label>
            <textarea id="pgnInput" placeholder="1. e4 e5 2. Nf3 Nc6 3. Bb5 a6 4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 8. c3 O-O"></textarea>

            <div style="margin-top: 15px; display: none;">
                <label style="display: block; margin-bottom: 8px; color: #888; font-size: 12px;">
                    Or analyze a single position (FEN)
                </label>
                <input type="text" id="fenInput" placeholder="rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1">
            </div>

            <div style="margin-top: 15px;">
                <button id="analyzeBtn" onclick="analyzeGame()" disabled>Analyze Game</button>
                <button id="analyzeFenBtn" onclick="analyzeFen()" disabled style="background: #0f3460; color: #00d4ff; display: none;">Analyze Position</button>
                <button onclick="clearResults()" style="background: #333; color: #888;">Clear</button>
            </div>

            <div class="progress-bar" id="progressBar" style="display: none;">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <div class="panel">
            <h2>Results</h2>

            <div id="openingInfo" style="display: none; background: #0f3460; padding: 12px; border-radius: 8px; margin-bottom: 15px;">
                <div style="font-size: 12px; color: #888; margin-bottom: 4px;">Opening</div>
                <div style="font-weight: bold; color: #00d4ff;" id="openingName">-</div>
            </div>

            <div id="openingDeviations" style="display: none; margin-bottom: 15px;"></div>

            <div class="stats" id="statsContainer" style="display: none;">
                <div class="stat-box blunders">
                    <div class="stat-value" id="blunderCount">0</div>
                    <div class="stat-label">Blunders</div>
                </div>
                <div class="stat-box mistakes">
                    <div class="stat-value" id="mistakeCount">0</div>
                    <div class="stat-label">Mistakes</div>
                </div>
                <div class="stat-box inaccuracies">
                    <div class="stat-value" id="inaccuracyCount">0</div>
                    <div class="stat-label">Inaccuracies</div>
                </div>
            </div>

            <div class="results" id="results">
                <p style="color: #888; text-align: center;">Enter a PGN and click Analyze to see results</p>
            </div>

            <!-- Analysis Report Container -->
            <div id="analysisReportContainer" style="display: none; margin-top: 15px; max-width: 400px; width: 100%; box-sizing: border-box;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; flex-wrap: wrap; gap: 8px;">
                    <span style="font-weight: bold; color: #00d4ff;">Full Analysis Report</span>
                    <span id="reportFilenameDisplay" style="color: #51cf66; font-size: 12px; margin-left: 10px;"></span>
                    <button id="toggleReportBtn" style="background: #0f3460; color: #00d4ff; padding: 6px 12px; font-size: 12px; border: none; border-radius: 6px; cursor: pointer;">Hide Report</button>
                </div>
                <div id="analysisReportText" style="
                    background: #ffffff;
                    color: #000000;
                    padding: 15px;
                    border-radius: 6px;
                    font-family: 'Courier New', monospace;
                    font-size: 14px;
                    line-height: 1.5;
                    max-height: 500px;
                    overflow-y: auto;
                    overflow-x: hidden;
                    white-space: pre-wrap;
                    word-wrap: break-word;
                    border: 1px solid #ccc;
                    box-sizing: border-box;
                ">Loading report...</div>
                <textarea id="reportEditTextarea" style="
                    display: none;
                    width: 100%;
                    min-height: 400px;
                    max-height: 500px;
                    background: white;
                    color: #333;
                    padding: 15px;
                    font-family: 'Courier New', monospace;
                    font-size: 14px;
                    line-height: 1.5;
                    resize: vertical;
                    border: 3px solid rgba(156, 39, 176, 0.5);
                    border-radius: 6px;
                    box-sizing: border-box;
                "></textarea>
                <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px;">
                    <button id="loadPgnFromHighlight" style="display: none; background: #17a2b8; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;">Load PGN from Highlight</button>
                    <button id="loadFenVariantFromHighlight" style="display: none; background: #6f42c1; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;">Load [Fen Variant] from Highlight</button>
                    <button id="copyReportText" style="background: #28a745; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;">Copy Text</button>
                    <button id="saveReportBtn" style="background: #28a745; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;">üíæ Save Report</button>
                    <button id="editViewToggleBtn" style="background: #9c27b0; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;">Edit</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Report Loading Controls (horizontal layout) -->
    <div id="reportControls" style="margin: 20px auto; padding: 12px 15px; background: #16213e; border-radius: 8px; max-width: 1200px; display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
      <button id="loadRefImageBtn" style="background: #17a2b8; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold;">üñºÔ∏è Load Reference Images</button>
      <input type="file" id="refImageFileInput" accept="image/*" multiple style="display: none;">
      <button id="loadAnalysisReport" style="background: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold;">Load Analysis Report (from clipboard)</button>
      <button id="selectReportFolder" style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold;" onclick="document.getElementById('reportFolderInput').click()">üìÇ Select Reports Folder</button>
      <input type="file" id="reportFolderInput" accept=".txt" webkitdirectory style="display: none;">
      <button id="loadPreloadedReports" style="background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold;">üìã Preloaded Reports</button>
      <span id="reportsCountDisplay" style="color: #51cf66; font-weight: bold;"></span>
      <button id="viewPreloadedReports" style="background: #6f42c1; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold; display: none;">üìã View Reports</button>
      <select id="openingDropdown" style="background: #1a1a2e; color: white; border: 2px solid #9c27b0; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-weight: bold; display: none;">
        <option value="">-- Select Opening --</option>
      </select>
      <button id="appendByOpeningBtn" style="background: linear-gradient(90deg, #9c27b0, #e91e63); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold; display: none;">üìö Append Opening Reports</button>
      <button id="saveSocraticBtn" style="background: #fd7e14; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold;">üìö Save Socratic Method</button>
      <button id="loadMistakesBtn" style="background: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold;">‚ö†Ô∏è Load Mistakes</button>
      <button id="removeMistakesBtn" style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold;">‚úì Remove Mistakes</button>
      <button id="loadFromVercelBtn" style="background: #8b5cf6; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold;">üì• Load from Vercel</button>
      <button id="saveToVercelBtn" style="background: #10b981; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold;">üì§ Save to Vercel</button>
    </div>

    <!-- Board and Move Table (side by side) -->
    <div style="display: flex; gap: 15px; flex-wrap: nowrap; margin: 20px auto; max-width: 1200px; align-items: flex-start;">
      <!-- Chess Board -->
      <div style="flex-shrink: 0;">
        <!-- Material Display -->
        <div id="materialDisplay" style="display: flex; justify-content: space-between; align-items: center; width: 400px; margin-bottom: 8px; font-size: 18px; min-height: 24px;">
          <div style="display: flex; align-items: center;">
            <span id="whiteCaptured" style="color: #fff; letter-spacing: 1px;"></span>
            <span id="whiteAdvantage" style="color: #4ade80; font-weight: bold; margin-left: 6px; font-size: 14px;"></span>
          </div>
          <div style="display: flex; align-items: center;">
            <span id="blackAdvantage" style="color: #4ade80; font-weight: bold; margin-right: 6px; font-size: 14px;"></span>
            <span id="blackCaptured" style="color: #fff; letter-spacing: 1px;"></span>
          </div>
        </div>
        <p style="color: #888; font-size: 12px; margin: 0 0 8px 0; font-style: italic;">Note: Chess piece images will load fully when choosing 'Next'</p>
        <div id="myBoard2" style="width: 400px;"></div>
      </div>

      <!-- Move Table Container with File Section Header -->
      <div style="flex: 1; min-width: 200px; display: flex; flex-direction: column;">
        <!-- File Section Header -->
        <div id="fileSectionHeader"
             style="display: none; background: linear-gradient(90deg, #1a1a2e, #16213e);
                    border: 1px solid #0f3460; border-bottom: none; border-radius: 5px 5px 0 0;
                    padding: 8px 12px; font-family: monospace;">
          <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px;">
            <button id="fileSectionPrev" style="background: #0f3460; color: #00d4ff; border: 1px solid #00d4ff;
                    width: 28px; height: 28px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">‚óÄ</button>
            <div style="flex: 1; text-align: center;">
              <span id="fileSectionName" style="color: #ffd700; font-size: 13px; font-weight: bold;"></span>
              <span id="fileSectionCounter" style="color: #888; font-size: 11px; margin-left: 8px;"></span>
            </div>
            <button id="fileSectionNext" style="background: #0f3460; color: #00d4ff; border: 1px solid #00d4ff;
                    width: 28px; height: 28px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">‚ñ∂</button>
          </div>
        </div>
        <!-- Move Table -->
        <div id="moveTableContainer"
             style="flex: 1; min-width: 200px; max-height: 450px; overflow-y: auto;
                    padding: 10px; background: #0f3460; border-radius: 5px;
                    font-family: monospace; font-size: 13px; line-height: 1.8; display: none;">
        </div>
      </div>
    </div>

    <!-- Board Navigation Container (full width) -->
    <div style="margin: 0 auto 20px; max-width: 1200px;">
      <div id="board2NavContainer" style="display: block; padding: 15px; background: #16213e; border-radius: 8px; width: 100%;">
        <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
          <button id="board2PrevMove" style="background: #00d4ff; color: #1a1a2e; border: none; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">‚Üê Prev</button>
          <span id="board2MoveIndicator" style="font-weight: bold; min-width: 60px; text-align: center; color: #eee;">Start</span>
          <button id="board2NextMove" style="background: #00d4ff; color: #1a1a2e; border: none; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">Next ‚Üí</button>
          <span id="currentFenMoves" style="color: #ffd700; font-family: monospace; font-size: 13px; font-weight: bold; min-width: 50px;"></span>
          <span id="board2PositionCount" style="font-weight: bold; color: #eee;">0/0</span>
          <button id="flip_board2" style="background: #00d4ff; color: #1a1a2e; border: none; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">Flip Board</button>
          <a id="lichessBoard2Link" href="#" target="_blank" style="color: #00d4ff; text-decoration: underline;">Go to Lichess (Analysis)</a>
          <div class="drag-scroll-toggle">
            <label class="switch">
                <input type="checkbox" id="dragScrollToggle">
                <span class="slider"></span>
            </label>
            <span class="toggle-label" id="dragScrollLabel">Auto Play</span>
          </div>
          <button id="resetAutoPlayBtn" style="background: #dc3545; color: white; border: none; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">Reset</button>
          <button id="loadPgnFromClipboard" style="background: #28a745; color: white; border: none; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">Load PGN from Clipboard</button>
          <button id="reloadGameFromReport" style="background: #fd7e14; color: white; border: none; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">Reload Game from Report</button>
          <button id="nextFenVariant" style="background: #e91e63; color: white; border: none; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">Next FEN</button>
          <button id="nextPgnVariant" style="background: #9c27b0; color: white; border: none; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">Next PGN</button>
          <button id="prevVariant" style="background: linear-gradient(90deg, #9c27b0, #e91e63); color: white; border: none; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">‚Üê Prev FEN/PGN</button>
          <button id="nextVariant" style="background: linear-gradient(90deg, #e91e63, #9c27b0); color: white; border: none; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">Next FEN/PGN ‚Üí</button>
          <span id="currentGameInfo" style="color: #51cf66; font-family: monospace; font-size: 12px; margin-left: 10px; max-width: 700px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; vertical-align: middle; line-height: 1.4;"></span>
          <br>
          <span id="variantNotesDisplay" style="color: #ffd700; font-family: monospace; font-size: 13px; font-style: italic; display: block;"></span>
          <button id="setVariantBtn" style="background: #17a2b8; color: white; border: none; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">Set Variant</button>
          <button id="reportAppendVariantBtn" style="display: none; background: #20c997; color: white; border: none; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">Report Append Variant</button>
          <span id="variantIndexDisplay" style="color: #00d4ff; font-family: monospace; font-size: 13px; margin-left: 10px; font-weight: bold;"></span>
        </div>
        <!-- Move History Textarea for Set Variant -->
        <textarea id="moveHistoryTextArea"
          style="width: 100%; height: 80px; margin-top: 10px; padding: 10px;
                 border: 2px solid #17a2b8; border-radius: 5px;
                 font-family: monospace; font-size: 13px;
                 background: #0f3460; color: #eee; resize: vertical; display: none;"
          placeholder="After clicking 'Set Variant', make moves on the board to build PGN..."
          readonly></textarea>
        <!-- All Comments Display -->
        <div id="allCommentsContainer"
             style="width: 100%; max-height: 150px; overflow-y: auto; margin-top: 10px;
                    padding: 10px; background: #1a1a2e; border: 1px solid #0f3460; border-radius: 5px;
                    font-family: monospace; font-size: 12px; line-height: 1.6; display: none;">
        </div>
      </div>
    </div>

    <!-- Reference Image Modal -->
    <div id="refImageModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
      <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #16213e; padding: 20px; border-radius: 8px; max-width: 90%; max-height: 90%;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
          <span id="refImageTitle" style="font-weight: bold; color: #00d4ff;">Reference Image</span>
          <button id="closeRefImageModal" style="background: #dc3545; color: white; border: none; padding: 5px 15px; border-radius: 6px; cursor: pointer;">Close</button>
        </div>
        <div id="refImagePlaceholder" style="text-align: center; padding: 40px; color: #888;">No image loaded</div>
        <div style="display: flex; justify-content: center; align-items: center; gap: 15px;">
          <button id="refImagePrevBtn" style="background: rgba(0,0,0,0.6); color: white; border: none; width: 40px; height: 40px; border-radius: 50%; cursor: pointer; font-size: 20px; display: none;">‚Äπ</button>
          <img id="refImagePreview" src="" alt="Reference Image" style="display: none; max-width: 100%; max-height: 70vh; cursor: zoom-in;">
          <button id="refImageNextBtn" style="background: rgba(0,0,0,0.6); color: white; border: none; width: 40px; height: 40px; border-radius: 50%; cursor: pointer; font-size: 20px; display: none;">‚Ä∫</button>
        </div>
        <div id="refImageCounter" style="color: #888; font-size: 14px; margin-top: 8px; text-align: center;"></div>
      </div>
    </div>

    <!-- Report Files Modal -->
    <div id="reportFilesModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
      <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #16213e; padding: 20px; border-radius: 8px; max-width: 600px; width: 90%; max-height: 80%; overflow-y: auto;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
          <h3 style="margin: 0; color: #00d4ff;">Select Report File</h3>
          <button id="closeReportFilesModal" style="background: #dc3545; color: white; border: none; padding: 5px 15px; border-radius: 6px; cursor: pointer;">Close</button>
        </div>
        <div id="reportFilesList" style="color: #eee;"></div>
      </div>
    </div>

    <div class="panel" style="margin-top: 20px;">
        <h2>Log</h2>
        <div id="log"></div>
    </div>

    <!-- jQuery (required for chessboard.js) -->
    <script src='https://code.jquery.com/jquery-2.2.4.min.js'></script>
    <!-- Chessboard.js -->
    <script src='https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js'></script>
    <!-- Chess.js for move parsing (local) -->
    <script src="chess.min.js"></script>
    <!-- Chess analysis utilities (PGN to UCI conversion) -->
    <script src="analysis_chess.js"></script>

    <script>
        // =====================================================================
        // STOCKFISH.JS CLIENT-SIDE ENGINE
        // =====================================================================

        let stockfish = null;
        let isReady = false;
        let currentResolve = null;
        let analysisQueue = [];

        // Thresholds (in centipawns) - stricter thresholds
        const BLUNDER_THRESHOLD = 300;     // 3 pawns
        const MISTAKE_THRESHOLD = 150;     // 1.5 pawns
        const INACCURACY_THRESHOLD = 50;   // 0.5 pawns

        // Initialize Stockfish Web Worker
        function initStockfish() {
            log('Initializing Stockfish.js...', 'info');

            try {
                // Load from local file (same directory as this HTML)
                stockfish = new Worker('stockfish.js');

                stockfish.onmessage = handleStockfishMessage;
                stockfish.onerror = (e) => {
                    log('Stockfish error: ' + e.message, 'error');
                };

                // Initialize UCI
                stockfish.postMessage('uci');

            } catch (e) {
                log('Failed to load Stockfish: ' + e.message, 'error');
                setStatus('error', 'Failed to load engine');
            }
        }

        function handleStockfishMessage(e) {
            const line = e.data;

            if (line === 'uciok') {
                log('Stockfish UCI initialized', 'success');
                stockfish.postMessage('isready');
            }
            else if (line === 'readyok') {
                isReady = true;
                setStatus('ready', 'Stockfish ready');
                document.getElementById('analyzeBtn').disabled = false;
                document.getElementById('analyzeFenBtn').disabled = false;
                document.getElementById('engineInfo').textContent = 'Stockfish.js (Client-side WASM)';
                log('Stockfish is ready!', 'success');
            }
            else if (line.startsWith('info depth')) {
                // Parse evaluation info
                const depthMatch = line.match(/depth (\d+)/);
                const scoreMatch = line.match(/score (cp|mate) (-?\d+)/);
                const pvMatch = line.match(/pv (.+)/);

                if (depthMatch && scoreMatch) {
                    const depth = parseInt(depthMatch[1]);
                    const scoreType = scoreMatch[1];
                    const scoreValue = parseInt(scoreMatch[2]);

                    // Update during analysis
                    if (depth >= 10) {
                        const evalStr = scoreType === 'mate'
                            ? `M${scoreValue}`
                            : (scoreValue / 100).toFixed(2);
                        // Could update UI here with intermediate results
                    }
                }
            }
            else if (line.startsWith('bestmove')) {
                // Analysis complete
                const bestMove = line.split(' ')[1];

                if (currentResolve) {
                    currentResolve({
                        bestMove: bestMove,
                        evaluation: currentEval
                    });
                    currentResolve = null;
                }
            }
        }

        let currentEval = 0;

        // Analyze a single position
        function analyzePosition(fen, targetDepth = 10) {
            return new Promise((resolve, reject) => {
                if (!isReady) {
                    reject(new Error('Stockfish not ready'));
                    return;
                }

                let finalEval = 0;
                let currentDepth = 0;
                let resolved = false;
                let timeoutId = null;

                const analysisHandler = (e) => {
                    const line = e.data;

                    // Capture evaluation at each depth
                    if (line.startsWith('info depth')) {
                        const depthMatch = line.match(/info depth (\d+)/);
                        const scoreMatch = line.match(/score (cp|mate) (-?\d+)/);

                        if (depthMatch && scoreMatch) {
                            const depth = parseInt(depthMatch[1]);
                            const scoreType = scoreMatch[1];
                            const scoreValue = parseInt(scoreMatch[2]);

                            // Only update if this is a deeper search
                            if (depth >= currentDepth) {
                                currentDepth = depth;
                                finalEval = scoreType === 'mate'
                                    ? (scoreValue > 0 ? 10000 - scoreValue : -10000 - scoreValue)
                                    : scoreValue;
                            }
                        }
                    }

                    // Analysis complete
                    if (line.startsWith('bestmove')) {
                        if (resolved) return;
                        resolved = true;
                        if (timeoutId) clearTimeout(timeoutId);

                        // Restore original handler
                        stockfish.onmessage = handleStockfishMessage;

                        resolve({
                            evaluation: finalEval,
                            depth: currentDepth
                        });
                    }
                };

                // Set up handler for this analysis
                stockfish.onmessage = analysisHandler;

                // Set up position and analyze
                stockfish.postMessage('position fen ' + fen);
                stockfish.postMessage('go depth ' + targetDepth);

                // Timeout after 15 seconds per move - resolve with current eval if no response
                timeoutId = setTimeout(() => {
                    if (resolved) return;
                    resolved = true;

                    stockfish.postMessage('stop');
                    stockfish.onmessage = handleStockfishMessage;

                    log('Position analysis timed out, using partial result', 'warning');
                    resolve({
                        evaluation: finalEval,
                        depth: currentDepth
                    });
                }, 5000);
            });
        }

        // =====================================================================
        // LICHESS OPENING EXPLORER API
        // =====================================================================

        async function getOpeningName(fen) {
            try {
                const response = await fetch(
                    `https://explorer.lichess.ovh/masters?fen=${encodeURIComponent(fen)}`
                );

                if (!response.ok) return null;

                const data = await response.json();

                if (data.opening) {
                    return {
                        eco: data.opening.eco,
                        name: data.opening.name
                    };
                }
                return null;
            } catch (e) {
                return null;
            }
        }

        async function getOpeningMoves(fen) {
            try {
                const response = await fetch(
                    `https://explorer.lichess.ovh/masters?fen=${encodeURIComponent(fen)}&topGames=0`
                );

                if (!response.ok) return null;

                const data = await response.json();

                if (data.moves && data.moves.length > 0) {
                    const totalGames = data.white + data.draws + data.black;
                    return {
                        moves: data.moves.slice(0, 5).map(m => ({
                            san: m.san,
                            games: m.white + m.draws + m.black,
                            percentage: totalGames > 0
                                ? ((m.white + m.draws + m.black) / totalGames * 100).toFixed(1)
                                : 0,
                            whiteWinRate: m.white + m.draws + m.black > 0
                                ? ((m.white / (m.white + m.draws + m.black)) * 100).toFixed(0)
                                : 0
                        })),
                        totalGames: totalGames,
                        opening: data.opening
                    };
                }
                return null;
            } catch (e) {
                return null;
            }
        }

        // =====================================================================
        // LICHESS CLOUD EVAL
        // =====================================================================

        async function lichessCloudEval(fen) {
            try {
                const response = await fetch(
                    `https://lichess.org/api/cloud-eval?fen=${encodeURIComponent(fen)}&multiPv=1`
                );

                if (response.status === 404) {
                    return null;
                }

                const data = await response.json();

                if (data.pvs && data.pvs[0]) {
                    const pv = data.pvs[0];
                    let score;

                    if (pv.mate !== undefined) {
                        score = pv.mate > 0 ? 10000 - pv.mate : -10000 - pv.mate;
                    } else {
                        score = pv.cp || 0;
                    }

                    return {
                        score: score,
                        bestMove: pv.moves ? pv.moves.split(' ')[0] : null,
                        source: 'lichess_cloud',
                        depth: data.depth
                    };
                }

                return null;
            } catch (e) {
                log('Lichess API error: ' + e.message, 'warning');
                return null;
            }
        }

        // =====================================================================
        // GAME ANALYSIS
        // =====================================================================

        async function analyzeGame() {
            let pgn = document.getElementById('pgnInput').value.trim();
            if (!pgn) {
                log('Please enter a PGN', 'error');
                return;
            }

            // Use AnalysisChess module if available, otherwise fallback
            if (typeof AnalysisChess !== 'undefined') {
                pgn = AnalysisChess.cleanPgn(pgn);
                log('Cleaned PGN using AnalysisChess module', 'info');
            } else {
                pgn = cleanPgn(pgn);
                log('Cleaned PGN of annotations', 'info');
            }

            const depth = parseInt(document.getElementById('depth').value);
            const useCloud = document.getElementById('engineSource').value === 'lichess';

            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('progressBar').style.display = 'block';
            document.getElementById('progressFill').style.width = '3%'; // Show initial progress to indicate activity
            document.getElementById('statsContainer').style.display = 'grid';
            document.getElementById('results').innerHTML = '<p style="color: #888;">Analyzing...</p>';

            setStatus('working', 'Analyzing...');
            log('Starting game analysis...', 'info');

            try {
                const chess = new Chess();

                // Try to load PGN
                if (!chess.load_pgn(pgn)) {
                    chess.reset();
                    const moves = pgn.replace(/\d+\./g, '').trim().split(/\s+/);
                    for (const move of moves) {
                        if (move && !chess.move(move)) {
                            throw new Error(`Invalid move: ${move}`);
                        }
                    }
                }

                const history = chess.history({ verbose: true });
                const totalMoves = history.length;

                // Log UCI moves if AnalysisChess is available
                if (typeof AnalysisChess !== 'undefined') {
                    const uciMoves = history.map(m => m.from + m.to + (m.promotion || ''));
                    log(`UCI moves: ${uciMoves.slice(0, 5).join(', ')}...`, 'info');
                }

                log(`Parsed ${totalMoves} moves`, 'info');

                // Detect opening and deviations from theory
                let openingInfo = null;
                let openingDeviations = [];
                let leftBook = false;
                let leftBookAtMove = null;

                const tempChess = new Chess();
                for (let i = 0; i < Math.min(history.length, 30); i++) {
                    const fenBefore = tempChess.fen();
                    const movePlayed = history[i].san;
                    const moveNum = Math.floor(i / 2) + 1;
                    const isWhite = i % 2 === 0;
                    const notation = isWhite ? `${moveNum}.` : `${moveNum}...`;

                    const bookData = await getOpeningMoves(fenBefore);

                    tempChess.move(movePlayed);

                    const opening = await getOpeningName(tempChess.fen());
                    if (opening) {
                        openingInfo = opening;
                    }

                    if (bookData && bookData.moves.length > 0 && !leftBook) {
                        const bookMoves = bookData.moves.map(m => m.san);
                        const isBookMove = bookMoves.includes(movePlayed);
                        const topMove = bookData.moves[0];

                        if (!isBookMove) {
                            leftBook = true;
                            leftBookAtMove = notation;

                            const mainLineMoves = bookData.moves.slice(0, 3)
                                .map(m => `${m.san} (${m.percentage}%)`)
                                .join(', ');

                            openingDeviations.push({
                                notation: notation,
                                movePlayed: movePlayed,
                                isWhite: isWhite,
                                mainLine: topMove.san,
                                mainLinePercentage: topMove.percentage,
                                alternatives: mainLineMoves,
                                totalGames: bookData.totalGames,
                                fen: fenBefore
                            });

                            log(`${notation} ${movePlayed}: Left opening theory! Main line was ${topMove.san} (${topMove.percentage}%)`, 'warning');
                        }
                    } else if (!bookData || bookData.moves.length === 0) {
                        if (!leftBook) {
                            leftBook = true;
                            leftBookAtMove = notation;
                        }
                    }
                }

                if (openingInfo) {
                    log(`Opening: ${openingInfo.eco} - ${openingInfo.name}`, 'success');
                }
                if (leftBookAtMove && openingDeviations.length === 0) {
                    log(`Left book at move ${leftBookAtMove} (end of theory)`, 'info');
                }

                chess.reset();

                const mistakes = [];
                let blunders = 0, mistakeCount = 0, inaccuracyCount = 0;

                log('Analyzing all positions...', 'info');
                const evaluations = [];

                let result;
                if (useCloud) {
                    const cloudResult = await lichessCloudEval(chess.fen());
                    result = cloudResult ? cloudResult.score : 0;
                } else {
                    const sfResult = await analyzePosition(chess.fen(), depth);
                    result = sfResult.evaluation;
                }
                evaluations.push(result);

                for (let i = 0; i < history.length; i++) {
                    chess.move(history[i].san);
                    const currentFen = chess.fen();

                    try {
                        if (useCloud) {
                            const cloudResult = await lichessCloudEval(currentFen);
                            result = cloudResult ? cloudResult.score : 0;
                        } else {
                            const sfResult = await analyzePosition(currentFen, depth);
                            result = sfResult.evaluation;
                        }
                    } catch (evalError) {
                        log(`Error evaluating move ${i + 1}: ${evalError.message}`, 'warning');
                        result = evaluations.length > 0 ? evaluations[evaluations.length - 1] : 0;
                    }
                    evaluations.push(result);

                    const progress = ((i + 1) / totalMoves) * 100;
                    document.getElementById('progressFill').style.width = progress + '%';

                    // Log progress every 10 moves or on last move
                    if ((i + 1) % 10 === 0 || i === history.length - 1) {
                        log(`Analyzed ${i + 1}/${totalMoves} positions...`, 'info');
                    }
                }

                chess.reset();

                log(`Evaluations complete: ${evaluations.length} positions analyzed`, 'info');
                log('Identifying mistakes...', 'info');
                for (let i = 0; i < history.length; i++) {
                    const move = history[i];
                    const moveNum = Math.floor(i / 2) + 1;
                    const isWhite = i % 2 === 0;
                    const notation = isWhite ? `${moveNum}.` : `${moveNum}...`;

                    const fenBefore = chess.fen();

                    let evalBefore = evaluations[i];
                    let evalAfter = evaluations[i + 1];

                    let swing;
                    let evalBeforeForDisplay, evalAfterForDisplay;

                    // Match analyze_game.js logic:
                    // Normalize scores to White's perspective, then calculate change
                    // based on who moved

                    if (useCloud) {
                        // Lichess Cloud: scores are from White's perspective
                        const prevWhiteScore = evalBefore;
                        const currWhiteScore = evalAfter;

                        if (isWhite) {
                            // White just moved: negative change = White got worse
                            swing = currWhiteScore - prevWhiteScore;
                            evalBeforeForDisplay = evalBefore;
                            evalAfterForDisplay = evalAfter;
                        } else {
                            // Black just moved: if White's score increased, Black got worse
                            swing = prevWhiteScore - currWhiteScore;
                            evalBeforeForDisplay = -evalBefore;
                            evalAfterForDisplay = -evalAfter;
                        }
                    } else {
                        // Stockfish.js: scores from side-to-move perspective
                        // evalBefore: from the mover's perspective (before they move)
                        // evalAfter: from opponent's perspective (after move)

                        // Convert to White's perspective
                        const prevWhiteScore = isWhite ? evalBefore : -evalBefore;
                        const currWhiteScore = isWhite ? -evalAfter : evalAfter;

                        if (isWhite) {
                            swing = currWhiteScore - prevWhiteScore;
                            evalBeforeForDisplay = prevWhiteScore;
                            evalAfterForDisplay = currWhiteScore;
                        } else {
                            swing = prevWhiteScore - currWhiteScore;
                            evalBeforeForDisplay = -prevWhiteScore;
                            evalAfterForDisplay = -currWhiteScore;
                        }
                    }

                    chess.move(move.san);

                    let severity = null;
                    if (swing <= -BLUNDER_THRESHOLD) {
                        severity = 'BLUNDER';
                        blunders++;
                    } else if (swing <= -MISTAKE_THRESHOLD) {
                        severity = 'MISTAKE';
                        mistakeCount++;
                    } else if (swing <= -INACCURACY_THRESHOLD && Math.abs(evalBeforeForDisplay) > 100) {
                        // Only flag inaccuracies when position is already unequal (beyond ¬±1 pawn)
                        severity = 'INACCURACY';
                        inaccuracyCount++;
                    }

                    if (severity) {
                        mistakes.push({
                            notation: notation,
                            move: move.san,
                            severity: severity,
                            evalBefore: evalBeforeForDisplay,
                            evalAfter: evalAfterForDisplay,
                            swing: swing,
                            fen: fenBefore
                        });
                        log(`${notation} ${move.san}: ${severity} (${swing} cp)`,
                            severity === 'BLUNDER' ? 'error' : severity === 'MISTAKE' ? 'warning' : 'info');
                    }
                }

                if (openingInfo) {
                    document.getElementById('openingInfo').style.display = 'block';
                    document.getElementById('openingName').textContent = `${openingInfo.eco}: ${openingInfo.name}`;
                } else {
                    document.getElementById('openingInfo').style.display = 'none';
                }

                const deviationsEl = document.getElementById('openingDeviations');
                if (openingDeviations.length > 0) {
                    let html = `
                        <div style="background: #1a1a2e; border: 1px solid #ffa94d; border-radius: 8px; padding: 12px;">
                            <div style="font-size: 12px; color: #ffa94d; margin-bottom: 8px; font-weight: bold;">
                                Opening Deviation
                            </div>
                    `;

                    for (const dev of openingDeviations) {
                        const fenEncoded = dev.fen.replace(/ /g, '_');
                        html += `
                            <div style="background: #0f3460; padding: 10px; border-radius: 6px; margin-bottom: 8px;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span style="font-weight: bold;">${dev.notation} ${dev.movePlayed}</span>
                                    <span style="font-size: 11px; background: #ffa94d; color: #1a1a2e; padding: 2px 6px; border-radius: 4px;">
                                        OUT OF BOOK
                                    </span>
                                </div>
                                <div style="margin-top: 8px; font-size: 13px; color: #aaa;">
                                    Main line: <strong style="color: #51cf66;">${dev.mainLine}</strong>
                                    <span style="color: #888;">(${dev.mainLinePercentage}% of ${dev.totalGames.toLocaleString()} master games)</span>
                                </div>
                                <div style="margin-top: 4px; font-size: 12px; color: #888;">
                                    Theory: ${dev.alternatives}
                                </div>
                                <div style="margin-top: 8px;">
                                    <a href="https://lichess.org/analysis/${fenEncoded}" target="_blank"
                                       style="font-size: 12px; color: #00d4ff; text-decoration: none;">
                                        Study this position on Lichess
                                    </a>
                                </div>
                            </div>
                        `;
                    }

                    html += '</div>';
                    deviationsEl.innerHTML = html;
                    deviationsEl.style.display = 'block';
                } else {
                    deviationsEl.style.display = 'none';
                }

                document.getElementById('blunderCount').textContent = blunders;
                document.getElementById('mistakeCount').textContent = mistakeCount;
                document.getElementById('inaccuracyCount').textContent = inaccuracyCount;

                log('Generating report...', 'info');
                displayResults(mistakes, openingInfo, openingDeviations);

                setStatus('ready', 'Analysis complete');
                log(`Analysis complete: ${blunders} blunders, ${mistakeCount} mistakes, ${inaccuracyCount} inaccuracies`, 'success');
                log('Report generated successfully', 'success');

            } catch (e) {
                log('Analysis error: ' + e.message, 'error');
                setStatus('ready', 'Error - check log');
            }

            document.getElementById('analyzeBtn').disabled = false;
            document.getElementById('progressBar').style.display = 'none';
        }

        async function analyzeFen() {
            const fen = document.getElementById('fenInput').value.trim();
            if (!fen) {
                log('Please enter a FEN', 'error');
                return;
            }

            document.getElementById('analyzeFenBtn').disabled = true;
            setStatus('working', 'Analyzing position...');
            log('Analyzing position: ' + fen, 'info');

            try {
                const depth = parseInt(document.getElementById('depth').value);
                const useCloud = document.getElementById('engineSource').value === 'lichess';

                let result;
                if (useCloud) {
                    result = await lichessCloudEval(fen);
                    if (!result) {
                        log('Position not in Lichess cloud, trying Stockfish...', 'warning');
                        result = await analyzePosition(fen, depth);
                        result = { score: result.evaluation, bestMove: result.bestMove };
                    }
                } else {
                    const sfResult = await analyzePosition(fen, depth);
                    result = { score: sfResult.evaluation, bestMove: sfResult.bestMove };
                }

                const evalStr = (result.score / 100).toFixed(2);
                document.getElementById('results').innerHTML = `
                    <div class="result-item">
                        <div class="result-header">
                            <span class="move-info">Position Evaluation</span>
                            <span class="eval-change">${result.score > 0 ? '+' : ''}${evalStr}</span>
                        </div>
                        <div>Best move: <strong>${result.bestMove || 'N/A'}</strong></div>
                        <div style="margin-top: 8px;">
                            <a class="fen-link" href="https://lichess.org/analysis/${fen.replace(/ /g, '_')}" target="_blank">
                                Analyze on Lichess
                            </a>
                        </div>
                    </div>
                `;

                log(`Evaluation: ${evalStr} | Best: ${result.bestMove}`, 'success');
                setStatus('ready', 'Analysis complete');

            } catch (e) {
                log('Error: ' + e.message, 'error');
                setStatus('ready', 'Error');
            }

            document.getElementById('analyzeFenBtn').disabled = false;
        }

        function displayResults(mistakes, openingInfo, openingDeviations) {
            // Hide the old results div - we're using the report container now
            document.getElementById('results').innerHTML = '';

            // Show the report container
            const reportContainer = document.getElementById('analysisReportContainer');
            const reportText = document.getElementById('analysisReportText');
            reportContainer.style.display = 'block';

            // Reset edit mode if active (fixes disconnect when generating new report while editing)
            const textarea = document.getElementById('reportEditTextarea');
            const editToggleBtn = document.getElementById('editViewToggleBtn');
            if (textarea && textarea.style.display !== 'none') {
                textarea.style.display = 'none';
                reportText.style.display = 'block';
                if (editToggleBtn) {
                    editToggleBtn.textContent = 'Edit';
                    editToggleBtn.style.background = '#9c27b0';
                }
                window.isReportEditMode = false;
            }

            // Count blunders, mistakes, and inaccuracies
            const blunders = mistakes.filter(m => m.severity === 'BLUNDER').length;
            const mistakeCount = mistakes.filter(m => m.severity === 'MISTAKE').length;
            const inaccuracyCount = mistakes.filter(m => m.severity === 'INACCURACY').length;

            // Build the report text (CLI-style format)
            let report = '';

            // Header
            report += '=' .repeat(70) + '\n';
            report += 'CHESS GAME ANALYSIS REPORT\n';
            report += `Generated: ${new Date().toLocaleString()}\n`;
            report += '=' .repeat(70) + '\n\n';

            // Opening info
            if (openingInfo) {
                report += `Opening: ${openingInfo.eco || ''} ${openingInfo.name || ''}\n\n`;
            }

            // Game Details (compact one-line format)
            const gameDropdown = document.getElementById('game-dropdown');
            const selectedLabel = gameDropdown ? gameDropdown.value : '';
            const gamesSource = fetchedGames[selectedLabel] ? fetchedGames : (window.fetchedGames || {});
            if (selectedLabel && gamesSource[selectedLabel]) {
                const meta = gamesSource[selectedLabel].metadata;
                report += `Game: White: ${meta.white} (${meta.white_rating}) vs Black: ${meta.black} (${meta.black_rating}) | ${meta.time_class} (${meta.time_control}) | Result: ${meta.result}${meta.url ? ' | ' + meta.url : ''}\n\n`;
            }

            // Game PGN
            const pgnInput = document.getElementById('pgnInput').value.trim();
            if (pgnInput) {
                report += 'GAME PGN\n';
                report += '-'.repeat(70) + '\n';
                report += pgnInput + '\n\n';
            }

            // Summary
            report += 'SUMMARY\n';
            report += '-' .repeat(70) + '\n';
            report += `Blunders: ${blunders}\n`;
            report += `Mistakes: ${mistakeCount}\n`;
            report += `Inaccuracies: ${inaccuracyCount}\n`;
            report += `Opening deviations: ${openingDeviations ? openingDeviations.length : 0}\n\n`;

            // Opening deviations section
            if (openingDeviations && openingDeviations.length > 0) {
                report += 'OPENING DEVIATIONS\n';
                report += '-' .repeat(70) + '\n';
                for (const dev of openingDeviations) {
                    report += `${dev.notation} ${dev.movePlayed} (book: ${dev.mainLine} ${dev.mainLinePercentage}%)\n`;
                    report += `  Alternatives: ${dev.alternatives}\n`;
                    const fenEncoded = dev.fen.replace(/ /g, '_');
                    report += `  https://lichess.org/analysis/${fenEncoded}\n\n`;
                }
            }

            // Mistakes, Blunders & Inaccuracies section
            if (mistakes.length > 0) {
                report += 'MISTAKES, BLUNDERS & INACCURACIES\n';
                report += '-' .repeat(70) + '\n';
                const mistakeLines = [];
                for (const err of mistakes) {
                    const evalBeforeStr = (err.evalBefore / 100).toFixed(2);
                    const evalAfterStr = (err.evalAfter / 100).toFixed(2);
                    const swingStr = (err.swing / 100).toFixed(2);
                    mistakeLines.push(`${err.severity}: ${err.notation} ${err.move}, Eval: ${evalBeforeStr} ‚Üí ${evalAfterStr} (${err.swing > 0 ? '+' : ''}${swingStr})`);
                }
                report += mistakeLines.join(', ') + '\n\n';
            }

            // Recommended puzzles section
            report += '=' .repeat(70) + '\n';
            report += 'RECOMMENDED PUZZLES TO PRACTICE\n';
            report += '=' .repeat(70) + '\n\n';

            // Determine puzzle themes based on mistakes
            const puzzleThemes = getPuzzleRecommendations(mistakes);

            if (puzzleThemes.length > 0) {
                report += 'Based on your game, practice these puzzle themes on Lichess:\n\n';
                for (const puzzle of puzzleThemes) {
                    report += `üéØ ${puzzle.theme}\n`;
                    report += `   ${puzzle.description}\n`;
                    report += `   Practice: ${puzzle.url}\n`;
                    if (puzzle.isDaily) {
                        report += `   ‚≠ê Bonus: Today's featured puzzle!\n`;
                    }
                    report += '\n';
                }
            } else {
                report += 'Great job! No significant weaknesses detected.\n';
                report += 'Keep practicing at: https://lichess.org/training\n\n';
            }

            // Key positions section
            const keyPositions = mistakes.filter(m => m.severity === 'BLUNDER' || m.severity === 'MISTAKE' || m.severity === 'INACCURACY');
            if (keyPositions.length > 0) {
                report += '=' .repeat(70) + '\n';
                report += 'KEY POSITIONS TO REVIEW\n';
                report += '=' .repeat(70) + '\n\n';
                report += 'Review these critical positions:\n\n';

                for (const err of keyPositions.slice(0, 5)) {
                    report += `Move ${err.notation} ${err.move}\n`;
                    const fenEncoded = err.fen.replace(/ /g, '_');
                    report += `  https://lichess.org/analysis/${fenEncoded}\n\n`;
                }
            }

            // Set the report text
            reportText.textContent = report;
            // Update game info display
            updateCurrentGameInfo(report);

            // Update filename display in header
            updateReportFilenameDisplay();

            // Store for later access
            window.analysisReportRawText = report;

            // Load PGN into board2 for navigation (reuse pgnInput from above)
            if (pgnInput && typeof window.parsePgnToPositions === 'function') {
                // Clean the PGN before parsing
                let cleanedPgn = pgnInput;
                if (typeof AnalysisChess !== 'undefined') {
                    cleanedPgn = AnalysisChess.cleanPgn(pgnInput);
                } else {
                    cleanedPgn = cleanPgn(pgnInput);
                }

                window.studyReportPositions = window.parsePgnToPositions(cleanedPgn);
                window.studyReportPositionIndex = 0;

                if (window.studyReportPositions && window.studyReportPositions.length > 0) {
                    if (window.board2) {
                        window.board2.position(window.studyReportPositions[0]);
                        updateBoard2MoveIndicator(0);
                    }
                    log(`Loaded ${window.studyReportPositions.length} positions to board`, 'success');
                }
            }
        }

        function getPuzzleRecommendations(mistakes) {
            const puzzles = [];
            const blunderCount = mistakes.filter(m => m.severity === 'BLUNDER').length;
            const mistakeCount = mistakes.filter(m => m.severity === 'MISTAKE').length;

            // Add puzzles based on error patterns
            if (blunderCount >= 2) {
                puzzles.push({
                    theme: 'Hanging Piece',
                    description: 'Win material by capturing undefended pieces',
                    url: 'https://lichess.org/training/hangingPiece',
                    isDaily: false
                });
            }

            if (blunderCount + mistakeCount >= 3) {
                puzzles.push({
                    theme: 'Middlegame',
                    description: 'Tactical puzzles from the middlegame',
                    url: 'https://lichess.org/training/middlegame',
                    isDaily: false
                });
            }

            if (mistakes.length > 0) {
                puzzles.push({
                    theme: 'Fork',
                    description: 'Attack two or more pieces simultaneously',
                    url: 'https://lichess.org/training/fork',
                    isDaily: false
                });
            }

            // Always add daily puzzle as bonus
            puzzles.push({
                theme: 'Daily Puzzle',
                description: "Today's featured puzzle from Lichess",
                url: 'https://lichess.org/training/daily',
                isDaily: true
            });

            return puzzles;
        }

        // Fallback cleanPgn if AnalysisChess not loaded
        function cleanPgn(pgn) {
            let cleaned = pgn.replace(/\$\d+/g, '');
            cleaned = cleaned.replace(/\{[^}]*\}/g, '');
            cleaned = cleaned.replace(/\([^)]*\)/g, '');
            cleaned = cleaned.replace(/\[%[^\]]*\]/g, '');
            cleaned = cleaned.replace(/\s+/g, ' ').trim();
            return cleaned;
        }

        // Generate report filename based on current game info
        function generateReportFilename() {
            let filenameParts = [];

            // Add date (month-day)
            const now = new Date();
            const monthDay = (now.getMonth() + 1).toString().padStart(2, '0') + '-' + now.getDate().toString().padStart(2, '0');
            filenameParts.push(monthDay);

            // Get White player name
            const gameDetails = document.getElementById('game-details');
            if (gameDetails) {
                const whiteMatch = gameDetails.textContent.match(/White:\s*(\w+)/);
                if (whiteMatch) filenameParts.push(whiteMatch[1]);
            }

            // Get color played
            const selectedGame = document.getElementById('game-dropdown');
            if (selectedGame && selectedGame.value.includes('as White')) {
                filenameParts.push('white');
            } else if (selectedGame && selectedGame.value.includes('as Black')) {
                filenameParts.push('black');
            }

            // Get 2nd and 3rd word from opening name
            const openingEl = document.getElementById('openingName');
            if (openingEl && openingEl.textContent && openingEl.textContent !== '-') {
                const words = openingEl.textContent.replace(/^[A-E]\d+:\s*/, '').split(/\s+/);
                if (words.length >= 2) filenameParts.push(words.slice(0, 2).join('_'));
            }

            return filenameParts.length > 0 ? filenameParts.join('_') + '.txt' : 'chess_report.txt';
        }

        // Update the filename display in the report header
        function updateReportFilenameDisplay() {
            const filenameDisplay = document.getElementById('reportFilenameDisplay');
            if (filenameDisplay) {
                const filename = generateReportFilename();
                filenameDisplay.textContent = 'üìÅ ' + filename;
            }
        }

        function clearResults() {
            document.getElementById('results').innerHTML =
                '<p style="color: #888; text-align: center;">Enter a PGN and click Analyze to see results</p>';
            document.getElementById('statsContainer').style.display = 'none';
            document.getElementById('openingInfo').style.display = 'none';
            document.getElementById('openingDeviations').style.display = 'none';
            document.getElementById('blunderCount').textContent = '0';
            document.getElementById('mistakeCount').textContent = '0';
            document.getElementById('inaccuracyCount').textContent = '0';
            document.getElementById('progressFill').style.width = '0%';
            // Hide the report container
            document.getElementById('analysisReportContainer').style.display = 'none';
            document.getElementById('analysisReportText').textContent = 'Loading report...';
            window.analysisReportRawText = null;
        }

        // =====================================================================
        // STOCKFISH VARIATION ADDER
        // =====================================================================

        // Store current variation analysis result
        window.currentVariationResult = null;

        function parseVariationMoveInput(input) {
            // Parse "12." or "12..." to get move number and color
            const match = input.trim().match(/^(\d+)(\.{1,3})$/);
            if (!match) return null;
            const moveNumber = parseInt(match[1]);
            const isBlack = match[2].length === 3; // "..." means black
            // Calculate ply index (0-indexed): move 1 white = 0, move 1 black = 1, etc.
            const plyIndex = (moveNumber - 1) * 2 + (isBlack ? 1 : 0);
            return { moveNumber, isBlack, plyIndex };
        }

        function getPositionsFromPgn(pgn) {
            // Use existing parsePgnToPositions if available
            if (typeof window.parsePgnToPositions === 'function') {
                let cleanedPgn = pgn;
                if (typeof AnalysisChess !== 'undefined') {
                    cleanedPgn = AnalysisChess.cleanPgn(pgn);
                } else if (typeof cleanPgn === 'function') {
                    cleanedPgn = cleanPgn(pgn);
                }
                return window.parsePgnToPositions(cleanedPgn);
            }
            return null;
        }

        function formatVariationWithMoveNumbers(pv, startMoveNumber, startsWithBlack) {
            // Format PV with proper move numbers: "10. d5 Ne7 11. h3 h5 12. b3"
            if (!pv || pv.length === 0) return '';

            let result = [];
            let currentMoveNum = startMoveNumber;
            let isBlackMove = startsWithBlack;

            for (let i = 0; i < pv.length; i++) {
                if (!isBlackMove) {
                    // White's move - add move number
                    result.push(`${currentMoveNum}. ${pv[i]}`);
                } else {
                    // Black's move - just the move (or with ... if first move)
                    if (i === 0) {
                        result.push(`${currentMoveNum}... ${pv[i]}`);
                    } else {
                        result.push(pv[i]);
                    }
                    currentMoveNum++;
                }
                isBlackMove = !isBlackMove;
            }

            return result.join(' ');
        }

        async function analyzeForVariation() {
            const input = document.getElementById('variation-move-input').value;
            const statusEl = document.getElementById('variation-status');
            const resultEl = document.getElementById('variation-result');
            const depth = parseInt(document.getElementById('variation-depth').value);

            // Parse move input
            const parsed = parseVariationMoveInput(input);
            if (!parsed) {
                statusEl.textContent = 'Invalid format. Use 12. or 12...';
                statusEl.style.color = '#ff6b6b';
                return;
            }

            // Get PGN
            const pgn = document.getElementById('pgnInput').value.trim();
            if (!pgn) {
                statusEl.textContent = 'No PGN loaded';
                statusEl.style.color = '#ff6b6b';
                return;
            }

            // Get positions
            const positions = getPositionsFromPgn(pgn);
            if (!positions || positions.length === 0) {
                statusEl.textContent = 'Could not parse PGN';
                statusEl.style.color = '#ff6b6b';
                return;
            }

            // Check if ply index is valid (we need the position BEFORE the move)
            if (parsed.plyIndex >= positions.length) {
                statusEl.textContent = `Move ${parsed.moveNumber}${parsed.isBlack ? '...' : '.'} not found`;
                statusEl.style.color = '#ff6b6b';
                return;
            }

            // Get FEN at position BEFORE the move (the position where the move was played from)
            const fen = positions[parsed.plyIndex];
            statusEl.textContent = `Analyzing at depth ${depth}...`;
            statusEl.style.color = '#00d4ff';

            // Disable button during analysis
            document.getElementById('analyze-variation-btn').disabled = true;

            try {
                // Use existing Stockfish analysis
                const result = await analyzePositionForVariation(fen, depth);

                if (result && result.bestMove) {
                    // Store result for adding to PGN
                    window.currentVariationResult = {
                        moveNumber: parsed.moveNumber,
                        isBlack: parsed.isBlack,
                        plyIndex: parsed.plyIndex,
                        fen: fen,
                        bestMove: result.bestMove,
                        score: result.score,
                        pv: result.pv || [result.bestMove]
                    };

                    // Format score
                    let scoreStr = '';
                    if (result.score !== undefined) {
                        if (typeof result.score === 'string' && result.score.startsWith('M')) {
                            scoreStr = `#${result.score.substring(1)}`;
                        } else {
                            scoreStr = (result.score >= 0 ? '+' : '') + (result.score / 100).toFixed(2);
                        }
                    }

                    // Format the line with proper move numbers
                    const formattedLine = formatVariationWithMoveNumbers(result.pv, parsed.moveNumber, parsed.isBlack);

                    document.getElementById('variation-best-move').textContent = `Stockfish: ${scoreStr}`;
                    document.getElementById('variation-line').textContent = formattedLine;
                    resultEl.style.display = 'block';
                    statusEl.textContent = '';

                    // Automatically add variation to PGN
                    addVariationToPgn();
                } else {
                    statusEl.textContent = 'No result from Stockfish';
                    statusEl.style.color = '#ff6b6b';
                }
            } catch (e) {
                statusEl.textContent = 'Analysis error: ' + e.message;
                statusEl.style.color = '#ff6b6b';
            }

            document.getElementById('analyze-variation-btn').disabled = false;
        }

        function analyzePositionForVariation(fen, depth) {
            return new Promise((resolve, reject) => {
                if (!stockfish) {
                    reject(new Error('Stockfish not ready'));
                    return;
                }

                let bestMove = null;
                let score = null;
                let pvUci = [];

                const handler = (e) => {
                    const line = e.data;

                    // Parse info lines for PV and score
                    if (line.startsWith('info') && line.includes('pv')) {
                        const pvMatch = line.match(/\spv\s+(.+)/);
                        if (pvMatch) {
                            pvUci = pvMatch[1].split(' ');
                        }
                        const scoreMatch = line.match(/score (cp|mate) (-?\d+)/);
                        if (scoreMatch) {
                            if (scoreMatch[1] === 'mate') {
                                score = 'M' + scoreMatch[2];
                            } else {
                                score = parseInt(scoreMatch[2]);
                            }
                        }
                    }

                    // Parse bestmove
                    if (line.startsWith('bestmove')) {
                        const match = line.match(/bestmove\s+(\S+)/);
                        if (match) {
                            bestMove = match[1];
                        }
                        stockfish.onmessage = handleStockfishMessage;

                        // Convert UCI moves to SAN using AnalysisChess
                        let pvSan = [];
                        if (typeof AnalysisChess !== 'undefined' && pvUci.length > 0) {
                            let currentFen = fen;
                            for (const uciMove of pvUci.slice(0, 5)) {
                                const result = AnalysisChess.uciToSan(currentFen, uciMove);
                                if (result.san) {
                                    pvSan.push(result.san);
                                    // Get new FEN after this move
                                    try {
                                        const chess = new Chess(currentFen);
                                        chess.move(result.san);
                                        currentFen = chess.fen();
                                    } catch (e) {
                                        break;
                                    }
                                } else {
                                    break;
                                }
                            }
                        }

                        resolve({
                            bestMove: pvSan.length > 0 ? pvSan[0] : bestMove,
                            score,
                            pv: pvSan.length > 0 ? pvSan : pvUci.slice(0, 5)
                        });
                    }
                };

                stockfish.onmessage = handler;
                stockfish.postMessage('position fen ' + fen);
                stockfish.postMessage('go depth ' + depth);
            });
        }

        function addVariationToPgn() {
            if (!window.currentVariationResult) {
                return;
            }

            const result = window.currentVariationResult;
            const pgnTextarea = document.getElementById('pgnInput');
            let pgn = pgnTextarea.value;

            // Format score
            let scoreStr = '';
            if (result.score !== undefined) {
                if (typeof result.score === 'string' && result.score.startsWith('M')) {
                    scoreStr = `#${result.score.substring(1)}`;
                } else {
                    scoreStr = (result.score >= 0 ? '+' : '') + (result.score / 100).toFixed(2);
                }
            }

            // Format the variation with proper move numbers
            const formattedPv = formatVariationWithMoveNumbers(result.pv, result.moveNumber, result.isBlack);
            const variation = `(${formattedPv} {Stockfish: ${scoreStr}})`;

            // Protect existing variations by replacing them temporarily
            // This prevents matching moves inside existing parentheses
            const variationPlaceholders = [];
            let protectedPgn = pgn.replace(/\([^()]*\)/g, (match) => {
                const placeholder = `__VAR${variationPlaceholders.length}__`;
                variationPlaceholders.push(match);
                return placeholder;
            });
            // Handle nested variations (repeat until no more matches)
            while (/\([^()]*\)/.test(protectedPgn)) {
                protectedPgn = protectedPgn.replace(/\([^()]*\)/g, (match) => {
                    const placeholder = `__VAR${variationPlaceholders.length}__`;
                    variationPlaceholders.push(match);
                    return placeholder;
                });
            }

            let inserted = false;

            if (result.isBlack) {
                // Black's move: find "N. whiteMove N... blackMove" or "N. whiteMove blackMove"
                const pattern = new RegExp(
                    `(${result.moveNumber}\\.\\s*\\S+\\s+)(${result.moveNumber}\\.{3}\\s*)?(\\S+)`,
                    'g'
                );
                protectedPgn = protectedPgn.replace(pattern, (match, whitePart, blackNumPart, blackMove) => {
                    if (!inserted && !blackMove.startsWith('__VAR')) {
                        inserted = true;
                        return whitePart + (blackNumPart || '') + blackMove + ' ' + variation;
                    }
                    return match;
                });
            } else {
                // White's move: find "N. whiteMove" and insert after
                const pattern = new RegExp(
                    `(${result.moveNumber}\\.\\s*)(\\S+)(\\s+)`,
                    'g'
                );
                protectedPgn = protectedPgn.replace(pattern, (match, moveNum, whiteMove, space) => {
                    if (!inserted && !whiteMove.startsWith('__VAR')) {
                        inserted = true;
                        return moveNum + whiteMove + ' ' + variation + space;
                    }
                    return match;
                });
            }

            // Restore protected variations
            for (let i = variationPlaceholders.length - 1; i >= 0; i--) {
                protectedPgn = protectedPgn.replace(`__VAR${i}__`, variationPlaceholders[i]);
            }

            if (inserted) {
                pgnTextarea.value = protectedPgn;
                document.getElementById('variation-status').textContent = '';

                // Flash the button to show feedback
                const addBtn = document.getElementById('add-variation-btn');
                const originalText = addBtn.textContent;
                addBtn.textContent = 'Added var.!';
                addBtn.style.background = '#2ecc71';
                setTimeout(() => {
                    addBtn.textContent = originalText;
                    addBtn.style.background = '#27ae60';
                }, 1500);

                // Reload positions
                if (typeof window.parsePgnToPositions === 'function') {
                    let cleanedPgn = protectedPgn;
                    if (typeof AnalysisChess !== 'undefined') {
                        cleanedPgn = AnalysisChess.cleanPgn(protectedPgn);
                    }
                    window.studyReportPositions = window.parsePgnToPositions(cleanedPgn);
                }
            } else {
                document.getElementById('variation-status').textContent = 'Could not insert variation';
                document.getElementById('variation-status').style.color = '#ff6b6b';
            }
        }

        function clearVariationResult() {
            document.getElementById('variation-result').style.display = 'none';
            document.getElementById('variation-status').textContent = '';
            document.getElementById('variation-move-input').value = '';
            window.currentVariationResult = null;
        }

        // =====================================================================
        // UI HELPERS
        // =====================================================================

        function setStatus(status, text) {
            const dot = document.getElementById('statusDot');
            const textEl = document.getElementById('statusText');

            dot.className = 'status-dot';
            if (status === 'ready') dot.classList.add('ready');
            if (status === 'working') dot.classList.add('working');

            textEl.textContent = text;
        }

        function log(message, type = 'info') {
            const logEl = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        // =====================================================================
        // CHESS.COM GAME FETCHER
        // =====================================================================

        let fetchedGames = window.fetchedGames || {};

        function validateUsername(username) {
            const pattern = /^[a-zA-Z0-9_]{3,25}$/;
            return pattern.test(username);
        }

        function extractPgnMoves(pgnText) {
            const lines = pgnText.split('\n');
            const moveLines = [];

            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed || trimmed.startsWith('[')) {
                    continue;
                }
                moveLines.push(trimmed);
            }

            let movesText = moveLines.join(' ');
            movesText = movesText.replace(/\{[^}]*\}/g, '');
            movesText = movesText.replace(/\([^)]*\)/g, '');
            movesText = movesText.replace(/\[%[^\]]*\]/g, '');
            movesText = movesText.replace(/\s+/g, ' ').trim();

            return movesText;
        }

        function extractOpeningFromPgn(pgnText) {
            // Extract ECO code: [ECO "C68"]
            const ecoMatch = pgnText.match(/\[ECO\s+"([^"]+)"\]/);
            const eco = ecoMatch ? ecoMatch[1] : '';

            // Try to get opening name from [Opening "..."] header first
            const openingMatch = pgnText.match(/\[Opening\s+"([^"]+)"\]/);
            if (openingMatch && openingMatch[1] !== 'Unknown') {
                return { eco, opening: openingMatch[1] };
            }

            // Parse from ECOUrl: https://www.chess.com/openings/Italian-Game-Giuoco-Piano
            const ecoUrlMatch = pgnText.match(/\[ECOUrl\s+"([^"]+)"\]/);
            if (ecoUrlMatch && ecoUrlMatch[1].includes('/openings/')) {
                let openingPart = ecoUrlMatch[1].split('/openings/')[1];
                // Remove move suffixes like "...4.Be2-O-O-5.O-O"
                openingPart = openingPart.replace(/\.\.\..*$/, '');
                openingPart = openingPart.replace(/-\d+\..*$/, '');
                // Replace hyphens with spaces
                const openingName = openingPart.replace(/-/g, ' ');
                if (openingName && openingName !== 'Undefined') {
                    return { eco, opening: openingName };
                }
            }

            return { eco, opening: '' };
        }

        function formatGameDate(timestamp) {
            if (!timestamp) return 'Unknown';
            const date = new Date(timestamp * 1000);
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }

        function showChesscomMessage(message, type) {
            clearChesscomMessages();

            const div = document.createElement('div');
            div.className = 'chesscom-message ' + type;
            div.textContent = message;

            const importBar = document.getElementById('chesscom-import-bar');
            importBar.parentNode.insertBefore(div, importBar.nextSibling);

            setTimeout(() => div.remove(), 5000);
        }

        function clearChesscomMessages() {
            const existing = document.querySelectorAll('.chesscom-message');
            existing.forEach(el => el.remove());
        }

        async function fetchChesscomGames() {
            const usernameInput = document.getElementById('chesscom-username');
            const fetchBtn = document.getElementById('fetch-games-btn');
            const gameSelectionContainer = document.getElementById('game-selection-container');
            const gameDropdown = document.getElementById('game-dropdown');
            const numGamesSelect = document.getElementById('num-games');

            const username = usernameInput.value.trim().toLowerCase();
            const numGames = parseInt(numGamesSelect.value);

            if (!username) {
                showChesscomMessage('Please enter a Chess.com username', 'error');
                return;
            }

            if (!validateUsername(username)) {
                showChesscomMessage('Invalid username format. Use 3-25 alphanumeric characters or underscores.', 'error');
                return;
            }

            clearChesscomMessages();
            fetchedGames = {};
            gameDropdown.innerHTML = '<option value="">-- Select a game --</option>';
            gameSelectionContainer.style.display = 'none';

            fetchBtn.disabled = true;
            fetchBtn.innerHTML = '<span class="chesscom-spinner"></span> Fetching...';
            log('Fetching games from Chess.com for: ' + username, 'info');

            try {
                const headers = { 'Accept': 'application/json' };
                let gamesList = [];

                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');

                const archiveUrl = `https://api.chess.com/pub/player/${username}/games/${year}/${month}`;

                try {
                    const response = await fetch(archiveUrl, { headers });

                    if (response.status === 404) {
                        throw new Error('User not found on Chess.com. Check the username and try again.');
                    }

                    if (response.ok) {
                        const data = await response.json();
                        if (data.games) {
                            gamesList = gamesList.concat(data.games);
                        }
                    }
                } catch (e) {
                    if (e.message.includes('User not found')) throw e;
                }

                if (gamesList.length < numGames) {
                    let prevMonth = now.getMonth();
                    let prevYear = year;
                    if (prevMonth === 0) {
                        prevMonth = 12;
                        prevYear -= 1;
                    }

                    const prevUrl = `https://api.chess.com/pub/player/${username}/games/${prevYear}/${String(prevMonth).padStart(2, '0')}`;

                    try {
                        const prevResponse = await fetch(prevUrl, { headers });
                        if (prevResponse.ok) {
                            const prevData = await prevResponse.json();
                            if (prevData.games) {
                                gamesList = gamesList.concat(prevData.games);
                            }
                        }
                    } catch (e) {
                        // Ignore errors from previous month
                    }
                }

                if (gamesList.length === 0) {
                    showChesscomMessage('No games found for this user in the last 2 months.', 'info');
                    log('No games found for ' + username, 'warning');
                    return;
                }

                gamesList.sort((a, b) => (b.end_time || 0) - (a.end_time || 0));
                const recentGames = gamesList.slice(0, numGames);

                for (let idx = 0; idx < recentGames.length; idx++) {
                    const game = recentGames[idx];
                    if (!game.pgn) continue;

                    const white = game.white || {};
                    const black = game.black || {};
                    const whiteUsername = white.username || 'Unknown';
                    const blackUsername = black.username || 'Unknown';
                    const whiteResult = white.result || '';
                    const blackResult = black.result || '';

                    let opponent, resultDisplay, playerColor;
                    if (username.toLowerCase() === whiteUsername.toLowerCase()) {
                        opponent = blackUsername;
                        playerColor = 'White';
                        if (whiteResult === 'win') resultDisplay = 'Win';
                        else if (blackResult === 'win') resultDisplay = 'Loss';
                        else resultDisplay = 'Draw';
                    } else {
                        opponent = whiteUsername;
                        playerColor = 'Black';
                        if (blackResult === 'win') resultDisplay = 'Win';
                        else if (whiteResult === 'win') resultDisplay = 'Loss';
                        else resultDisplay = 'Draw';
                    }

                    const gameDate = formatGameDate(game.end_time);
                    const timeClass = game.time_class || 'unknown';

                    const label = `Game ${idx + 1}: vs ${opponent} (${resultDisplay} as ${playerColor}) - ${timeClass} - ${gameDate}`;

                    // Extract opening info from PGN
                    const openingInfo = extractOpeningFromPgn(game.pgn);

                    fetchedGames[label] = {
                        pgn: extractPgnMoves(game.pgn),
                        fullPgn: game.pgn,
                        metadata: {
                            white: whiteUsername,
                            black: blackUsername,
                            white_rating: white.rating || '?',
                            black_rating: black.rating || '?',
                            result: resultDisplay,
                            time_class: timeClass,
                            time_control: game.time_control || '',
                            url: game.url || '',
                            end_time: game.end_time,
                            eco: openingInfo.eco,
                            opening: openingInfo.opening
                        }
                    };
                    window.fetchedGames = fetchedGames; // Sync to window for batch analysis
                }

                if (Object.keys(fetchedGames).length === 0) {
                    showChesscomMessage('No valid games found (games may be missing PGN data).', 'info');
                    return;
                }

                for (const label of Object.keys(fetchedGames)) {
                    const option = document.createElement('option');
                    option.value = label;
                    option.textContent = label;
                    gameDropdown.appendChild(option);
                }

                gameSelectionContainer.style.display = 'block';
                showChesscomMessage(`Found ${Object.keys(fetchedGames).length} recent games!`, 'success');
                log(`Fetched ${Object.keys(fetchedGames).length} games from Chess.com`, 'success');

            } catch (error) {
                showChesscomMessage(error.message || 'Failed to fetch games. Please try again.', 'error');
                log('Chess.com fetch error: ' + error.message, 'error');
                gameSelectionContainer.style.display = 'none';
            } finally {
                fetchBtn.disabled = false;
                fetchBtn.innerHTML = 'üì• Fetch Games';
            }
        }

        function loadSelectedGame() {
            const gameDropdown = document.getElementById('game-dropdown');
            const gameDetails = document.getElementById('game-details');
            const pgnTextarea = document.getElementById('pgnInput');

            const selectedLabel = gameDropdown.value;

            if (!selectedLabel || !fetchedGames[selectedLabel]) {
                gameDetails.innerHTML = '';
                return;
            }

            const game = fetchedGames[selectedLabel];
            const meta = game.metadata;

            // Format opening display
            let openingDisplay = '';
            if (meta.eco || meta.opening) {
                openingDisplay = `<p><strong>Opening:</strong> ${meta.eco ? meta.eco + ' ' : ''}${meta.opening || ''}</p>`;
            }

            gameDetails.innerHTML = `
                <p><strong>White:</strong> ${meta.white} (${meta.white_rating})</p>
                <p><strong>Black:</strong> ${meta.black} (${meta.black_rating})</p>
                ${openingDisplay}
                <p><strong>Time Control:</strong> ${meta.time_class} (${meta.time_control})</p>
                <p><strong>Result:</strong> ${meta.result}</p>
                ${meta.url ? `<p><a href="${meta.url}" target="_blank">View on Chess.com ‚Üó</a></p>` : ''}
            `;

            // Insert opening as comment after first move
            let pgnWithOpening = game.pgn;
            if (meta.eco || meta.opening) {
                const openingComment = `{${meta.eco ? meta.eco + ' ' : ''}${meta.opening || ''}}`;
                // Insert after first move: "1. e4" -> "1. e4 {Opening}"
                pgnWithOpening = pgnWithOpening.replace(
                    /^(1\.\s*\S+)/,
                    `$1 ${openingComment}`
                );
            }
            pgnTextarea.value = pgnWithOpening;
            log('Loaded game: ' + selectedLabel, 'info');

            // Show variation adder
            document.getElementById('variation-adder').style.display = 'block';

            // Load PGN into board2 for navigation
            if (game.pgn && typeof window.parsePgnToPositions === 'function') {
                let cleanedPgn = game.pgn;
                if (typeof AnalysisChess !== 'undefined') {
                    cleanedPgn = AnalysisChess.cleanPgn(game.pgn);
                } else if (typeof cleanPgn === 'function') {
                    cleanedPgn = cleanPgn(game.pgn);
                }

                window.studyReportPositions = window.parsePgnToPositions(cleanedPgn);
                window.studyReportPositionIndex = 0;

                if (window.studyReportPositions && window.studyReportPositions.length > 0) {
                    if (window.board2) {
                        window.board2.position(window.studyReportPositions[0]);
                        updateBoard2MoveIndicator(0);
                    }
                    log(`Loaded ${window.studyReportPositions.length} positions to board`, 'success');
                }
            }
        }

        // =====================================================================
        // STUDY TOOL - BOARD2 AND REPORT FUNCTIONALITY
        // =====================================================================

        // Global variables for study tool
        window.studyReportRawText = '';
        window.studyReportPositions = [];
        window.studyReportPositionIndex = 0;
        window.loadedReportFiles = [];
        window.loadedMistakes = {}; // { "12...": "MISTAKE", "13.": "MISTAKE", "17.": "BLUNDER" }

        // Move tree navigation (for variation support)
        window.moveTree = null;           // Root node of parsed move tree
        window.currentMoveNode = null;    // Currently selected node in the tree
        window.moveNodeRegistry = {};     // Map of nodeId -> MoveNode for fast lookup

        let refImageLoaded = false;
        let refImageIsEnlarged = false;
        let loadedRefImages = [];
        let currentRefImageIndex = 0;

        // Piece theme path for chess board (local images)
        const pieceThemePath = 'img/chesspieces/wikipedia/{piece}.png';

        /**
         * Check if text matches [Variant "From Position"][FEN "..."] format
         */
        window.isVariantFenContent = function(text) {
            if (!text || typeof text !== 'string') return false;
            const cleanText = text.trim();
            // Matches: [Variant "From Position"][FEN "rnbqkbnr/..."] optionally followed by moves
            return /\[Variant\s+"From\s+Position"\]\s*\[FEN\s+"[^"]+"\]/.test(cleanText);
        };

        /**
         * Parse PGN notation to array of FEN positions
         * Supports both standard PGN and [Variant "From Position"][FEN "..."] format
         */
        window.parsePgnToPositions = function(pgnString) {
            const positions = [];
            try {
                const chess = new Chess();

                // Check if text has a FEN header (from Variant format or standard PGN)
                const fenMatch = pgnString.match(/\[FEN\s+"([^"]+)"\]/);
                if (fenMatch) {
                    const startingFen = fenMatch[1];
                    try {
                        chess.load(startingFen);
                    } catch (fenError) {
                        console.warn('Failed to load FEN, using standard position:', fenError);
                        chess.reset();
                    }
                }

                positions.push(chess.fen()); // Starting position

                // Clean PGN - remove headers, comments, variations
                let cleanPgn = pgnString
                    .replace(/\[.*?\]/g, '') // Remove all headers [...]
                    .replace(/\{[^}]*\}/g, '') // Remove comments
                    .replace(/\([^)]*\)/g, '') // Remove variations
                    .replace(/\$\d+/g, '') // Remove NAG symbols $1, $2, etc.
                    .replace(/\d+\.\.\./g, '') // Remove black move indicators
                    .replace(/\s+/g, ' ')
                    .trim();

                // Extract moves
                const moveRegex = /([KQRBN]?[a-h]?[1-8]?x?[a-h][1-8](?:=[QRBN])?|O-O-O|O-O)(?:\+|#)?/g;
                let match;

                while ((match = moveRegex.exec(cleanPgn)) !== null) {
                    const move = match[1];
                    try {
                        const result = chess.move(move, { sloppy: true });
                        if (result) {
                            positions.push(chess.fen());
                        }
                    } catch (e) {
                        console.warn('Invalid move:', move);
                    }
                }
            } catch (e) {
                console.error('Error parsing PGN:', e);
            }
            return positions;
        };

        /**
         * NAG (Numeric Annotation Glyph) to symbol mapping
         * Converts PGN NAG codes like $1, $2, $4, $6 to their symbolic equivalents
         */
        const nagToSymbol = {
            '$1': '!',    // Good move
            '$2': '?',    // Mistake
            '$3': '!!',   // Brilliant move
            '$4': '??',   // Blunder
            '$5': '!?',   // Interesting move
            '$6': '?!',   // Dubious/questionable move
            '$7': '‚ñ°',    // Forced move (only move)
            '$8': '‚ñ°',    // Singular move
            '$9': '',     // Unclear position - skip/don't display
            '$10': '=',   // Equal position
            '$11': '=',   // Equal, quiet position
            '$12': '=',   // Equal, active position
            '$13': '‚àû',   // Unclear
            '$14': '+=',  // White slightly better
            '$15': '=+',  // Black slightly better
            '$16': '¬±',   // White clearly better
            '$17': '‚àì',   // Black clearly better
            '$18': '+-',  // White winning
            '$19': '-+',  // Black winning
            '$22': '‚®Ä',   // Zugzwang
            '$32': '‚ü≥',   // Development advantage
            '$36': '‚Üí',   // Initiative
            '$40': '‚Üë',   // Attack
            '$132': '‚áÜ',  // Counterplay
            '$138': '‚äï',  // Time pressure
            '$140': '‚àÜ',  // With the idea
            '$146': 'N',  // Novelty
        };

        /**
         * Convert NAG symbols in PGN text to their symbolic equivalents
         */
        function convertNagsToSymbols(pgnText) {
            return pgnText.replace(/\$(\d+)/g, function(match) {
                return nagToSymbol[match] || '';
            });
        }

        /**
         * Parse PGN notation to array of FEN positions WITH comments extracted
         * Returns { positions: [], comments: {} } where comments is keyed by position index
         */
        window.parsePgnToPositionsWithComments = function(pgnString) {
            const positions = [];
            const comments = {};  // Map of positionIndex -> comment text
            try {
                const chess = new Chess();

                // Check if text has a FEN header
                const fenMatch = pgnString.match(/\[FEN\s+"([^"]+)"\]/);
                if (fenMatch) {
                    const startingFen = fenMatch[1];
                    try {
                        chess.load(startingFen);
                    } catch (fenError) {
                        console.warn('Failed to load FEN, using standard position:', fenError);
                        chess.reset();
                    }
                }

                positions.push(chess.fen()); // Starting position

                // Remove headers and variations but PRESERVE comments initially
                let pgnBody = pgnString
                    .replace(/\[.*?\]/g, '')      // Remove headers
                    .replace(/\([^)]*\)/g, '')    // Remove variations
                    .replace(/\$\d+/g, '')        // Remove NAG symbols
                    .replace(/\d+\.\.\./g, '')    // Remove black move indicators
                    .trim();

                // Extract moves with their trailing comments
                // Pattern: move possibly followed by annotations (!?!???!) then {comment}
                const tokenRegex = /([KQRBN]?[a-h]?[1-8]?x?[a-h][1-8](?:=[QRBN])?|O-O-O|O-O)(?:\+|#)?[!?]*(?:\s*\{([^}]*)\})?/g;
                let match;

                while ((match = tokenRegex.exec(pgnBody)) !== null) {
                    const move = match[1];
                    const comment = match[2] ? match[2].trim() : null;

                    try {
                        const result = chess.move(move, { sloppy: true });
                        if (result) {
                            positions.push(chess.fen());
                            if (comment) {
                                comments[positions.length - 1] = comment;
                            }
                        }
                    } catch (e) {
                        console.warn('Invalid move:', move);
                    }
                }
            } catch (e) {
                console.error('Error parsing PGN with comments:', e);
            }
            return { positions, comments };
        };

        // Global storage for current variant's comments
        window.studyReportComments = {};

        /**
         * Tokenize PGN text preserving parentheses as tokens
         */
        function tokenizePgn(moveText) {
            const tokens = [];
            let current = '';
            let inComment = false;

            for (let i = 0; i < moveText.length; i++) {
                const char = moveText[i];

                if (char === '{') {
                    if (current.trim()) tokens.push(current.trim());
                    current = '{';
                    inComment = true;
                } else if (char === '}') {
                    current += '}';
                    tokens.push(current);
                    current = '';
                    inComment = false;
                } else if (inComment) {
                    current += char;
                } else if (char === '(' || char === ')') {
                    if (current.trim()) tokens.push(current.trim());
                    tokens.push(char);
                    current = '';
                } else if (/\s/.test(char)) {
                    if (current.trim()) tokens.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            if (current.trim()) tokens.push(current.trim());

            return tokens;
        }

        /**
         * Parse PGN with variations into a tree structure
         * Returns root node with children array
         */
        window.parsePgnWithVariations = function(pgnString) {
            // Extract starting FEN (if present)
            const fenMatch = pgnString.match(/\[FEN\s+"([^"]+)"\]/);
            const startingFen = fenMatch ? fenMatch[1] : 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';

            // Remove headers, keep move text
            let moveText = pgnString.replace(/\[.*?\]/g, '').trim();

            // Tokenize the PGN
            const tokens = tokenizePgn(moveText);

            // Initialize chess from starting position
            const chess = new Chess();
            try {
                chess.load(startingFen);
            } catch (e) {
                console.warn('Failed to load starting FEN:', e);
                chess.reset();
            }

            // Create root node
            const rootNode = {
                san: null,
                fen: chess.fen(),
                moveNumber: 0,
                isBlackMove: false,
                comment: '',
                parent: null,
                children: [],
                depth: 0,
                nodeId: 'root'
            };

            // Reset registry
            window.moveNodeRegistry = { 'root': rootNode };

            // Parse tokens into tree
            let nodeCounter = 0;
            parseTokensIntoTree(tokens, 0, chess, rootNode, 0, { counter: nodeCounter });

            return rootNode;
        };

        /**
         * Recursively parse tokens into a move tree
         */
        function parseTokensIntoTree(tokens, startIndex, chess, parentNode, depth, counterObj) {
            let i = startIndex;
            let lastMoveNode = parentNode;
            let branchChess = chess; // Chess instance for this branch

            while (i < tokens.length) {
                const token = tokens[i];

                if (token === '(') {
                    // Start of variation - branch from the position BEFORE the last move
                    // Find the correct branching point (parent of last move)
                    const branchPoint = lastMoveNode.parent || parentNode;

                    // Create a new chess instance from the branch point's position
                    const variationChess = new Chess();
                    variationChess.load(branchPoint.fen);

                    // Parse the variation recursively
                    i = parseTokensIntoTree(tokens, i + 1, variationChess, branchPoint, depth + 1, counterObj);
                    continue;
                }

                if (token === ')') {
                    // End of variation
                    return i + 1;
                }

                // Skip comments - they attach to the previous move
                if (token.startsWith('{')) {
                    const comment = token.slice(1, -1).trim();
                    if (lastMoveNode && lastMoveNode !== parentNode) {
                        lastMoveNode.comment = comment;
                    }
                    i++;
                    continue;
                }

                // Skip move numbers (1. 2. 1... etc)
                if (/^\d+\.+$/.test(token)) {
                    i++;
                    continue;
                }

                // Convert NAG symbols ($1, $2, etc.) and append to previous move's annotation
                if (/^\$\d+$/.test(token)) {
                    const nagSymbol = nagToSymbol[token] || '';
                    if (nagSymbol && lastMoveNode && lastMoveNode.nodeId !== 'root') {
                        lastMoveNode.annotation = (lastMoveNode.annotation || '') + nagSymbol;
                        console.log('Converted NAG:', token, '-> symbol:', nagSymbol, 'for move:', lastMoveNode.san);
                    }
                    i++;
                    continue;
                }

                // Skip result markers
                if (['1-0', '0-1', '1/2-1/2', '*'].includes(token)) {
                    i++;
                    continue;
                }

                // This is a move - try to make it
                try {
                    // First, strip any move number prefix (e.g., "12.Bg5" -> "Bg5")
                    let moveToken = token.replace(/^\d+\.+/, '');

                    // Extract annotation symbols (!, ?, !!, ??, !?, ?!) from the move
                    const annotationMatch = moveToken.match(/^(.+?)([!?]+)$/);
                    const cleanMove = annotationMatch ? annotationMatch[1] : moveToken;
                    const annotation = annotationMatch ? annotationMatch[2] : '';

                    if (annotation) {
                        console.log('Found annotation:', token, '-> move:', cleanMove, 'annotation:', annotation);
                    }

                    // Determine whose turn it was BEFORE the move
                    const turnBeforeMove = branchChess.turn();
                    const move = branchChess.move(cleanMove, { sloppy: true });
                    if (move) {
                        // Calculate move number based on parent's info
                        let moveNumber;
                        const isBlackMove = (turnBeforeMove === 'b');

                        if (lastMoveNode.nodeId === 'root') {
                            // First move from root - extract from FEN or default to 1
                            const fenParts = lastMoveNode.fen.split(' ');
                            moveNumber = fenParts.length >= 6 ? parseInt(fenParts[5]) || 1 : 1;
                        } else {
                            // Continue from parent's move number
                            if (isBlackMove) {
                                // Black's move - same move number as parent if parent was white
                                moveNumber = lastMoveNode.moveNumber;
                            } else {
                                // White's move - increment from parent
                                moveNumber = lastMoveNode.moveNumber + (lastMoveNode.isBlackMove ? 1 : 0);
                            }
                        }

                        const newNode = {
                            san: move.san,
                            annotation: annotation,
                            fen: branchChess.fen(),
                            moveNumber: moveNumber,
                            isBlackMove: isBlackMove,
                            comment: '',
                            parent: lastMoveNode,
                            children: [],
                            depth: depth,
                            nodeId: `node-${counterObj.counter++}`
                        };

                        // Add as child of current node
                        lastMoveNode.children.push(newNode);
                        window.moveNodeRegistry[newNode.nodeId] = newNode;
                        lastMoveNode = newNode;
                    }
                } catch (e) {
                    console.warn('Invalid move:', token, e);
                }

                i++;
            }

            return i;
        }

        /**
         * Get color for move based on annotation
         * ? (mistake) = red, ?! (dubious) = yellow, ?? (blunder) = dark red
         */
        function getAnnotationColor(annotation) {
            if (!annotation) return null;
            if (annotation.includes('??')) return '#ff4444'; // Blunder - bright red
            if (annotation.includes('?!')) return '#ffd700'; // Dubious - yellow
            if (annotation.includes('?') && !annotation.includes('!?')) return '#ff6b6b'; // Mistake - red
            return null; // No special color for good moves
        }

        /**
         * Render the move table with clickable moves and variations
         */
        function renderMoveTable(rootNode) {
            const container = document.getElementById('moveTableContainer');
            if (!container) return;

            container.innerHTML = '';
            container.style.display = 'block';

            // Render from root's children (the actual moves)
            if (rootNode.children && rootNode.children.length > 0) {
                renderMoveSequence(rootNode.children[0], container, true);
            }
        }

        /**
         * Render a sequence of moves starting from a node
         */
        function renderMoveSequence(startNode, container, isMainLine) {
            let node = startNode;
            let lastMoveNumber = 0;

            while (node) {
                // Add move number if it's white's move or first move in a line
                if (!node.isBlackMove && node.moveNumber !== lastMoveNumber) {
                    const numSpan = document.createElement('span');
                    numSpan.className = 'move-number';
                    numSpan.textContent = node.moveNumber + '. ';
                    container.appendChild(numSpan);
                    lastMoveNumber = node.moveNumber;
                }

                // The move itself (with annotation if present)
                const moveSpan = document.createElement('span');
                moveSpan.className = isMainLine ? 'move-san main-line' : 'move-san';
                moveSpan.textContent = node.san + (node.annotation || '');
                moveSpan.dataset.nodeId = node.nodeId;
                moveSpan.onclick = function() { jumpToNode(this.dataset.nodeId); };
                // Apply color based on annotation (? = red, ?! = yellow)
                const annotationColor = getAnnotationColor(node.annotation);
                if (annotationColor) {
                    moveSpan.style.color = annotationColor;
                }
                container.appendChild(moveSpan);

                // Check for variations (siblings - other children of parent besides this line)
                if (node.parent && node.parent.children.length > 1) {
                    const siblingIndex = node.parent.children.indexOf(node);
                    // Only show variations after the first child (main line continuation)
                    if (siblingIndex === 0) {
                        // Render other variations
                        for (let v = 1; v < node.parent.children.length; v++) {
                            const variation = node.parent.children[v];
                            renderVariation(variation, container);
                        }
                    }
                }

                // Continue with first child (main continuation)
                if (node.children && node.children.length > 0) {
                    node = node.children[0];
                } else {
                    break;
                }
            }
        }

        /**
         * Render a variation in parentheses
         */
        function renderVariation(startNode, container) {
            // Opening parenthesis
            const openParen = document.createElement('span');
            openParen.className = 'variation-container';
            openParen.textContent = '(';
            container.appendChild(openParen);

            // Render variation moves
            let node = startNode;
            let isFirst = true;

            while (node) {
                // Move number for first move in variation
                if (isFirst) {
                    const numSpan = document.createElement('span');
                    numSpan.className = 'move-number';
                    if (node.isBlackMove) {
                        numSpan.textContent = node.moveNumber + '... ';
                    } else {
                        numSpan.textContent = node.moveNumber + '. ';
                    }
                    container.appendChild(numSpan);
                    isFirst = false;
                } else if (!node.isBlackMove) {
                    // Add move number for white moves after first
                    const numSpan = document.createElement('span');
                    numSpan.className = 'move-number';
                    numSpan.textContent = node.moveNumber + '. ';
                    container.appendChild(numSpan);
                }

                // The move (with annotation if present)
                const moveSpan = document.createElement('span');
                moveSpan.className = 'variation-move';
                moveSpan.textContent = node.san + (node.annotation || '');
                moveSpan.dataset.nodeId = node.nodeId;
                moveSpan.onclick = function() { jumpToNode(this.dataset.nodeId); };
                // Apply color based on annotation (? = red, ?! = yellow)
                const annotationColor = getAnnotationColor(node.annotation);
                if (annotationColor) {
                    moveSpan.style.color = annotationColor;
                }
                container.appendChild(moveSpan);

                // Space after move
                container.appendChild(document.createTextNode(' '));

                // Continue with first child
                if (node.children && node.children.length > 0) {
                    node = node.children[0];
                } else {
                    break;
                }
            }

            // Closing parenthesis
            const closeParen = document.createElement('span');
            closeParen.className = 'variation-container';
            closeParen.textContent = ') ';
            container.appendChild(closeParen);
        }

        /**
         * Jump to a specific node in the move tree
         */
        function jumpToNode(nodeId) {
            const node = window.moveNodeRegistry[nodeId];
            if (!node) return;

            window.currentMoveNode = node;

            // Update board position
            if (window.board2) {
                window.board2.position(node.fen);
            }

            // Update highlighting in move table
            document.querySelectorAll('.move-san.current, .variation-move.current').forEach(el => {
                el.classList.remove('current');
            });
            const currentEl = document.querySelector(`[data-node-id="${nodeId}"]`);
            if (currentEl) {
                currentEl.classList.add('current');
                currentEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            // Reduce board opacity when viewing a variation
            const boardContainer = document.getElementById('myBoard2');
            if (boardContainer) {
                if (currentEl && currentEl.classList.contains('variation-move')) {
                    boardContainer.style.opacity = '0.6';
                } else {
                    boardContainer.style.opacity = '1';
                }
            }

            // Update other displays
            updateMaterialDisplay(node.fen);

            // Update Lichess link
            const lichessLink = document.getElementById('lichessBoard2Link');
            if (lichessLink) {
                const fen = node.fen;
                lichessLink.href = `https://lichess.org/analysis/${fen.replace(/ /g, '_')}`;
            }

            // Update variant notes display with comment
            const variantNotesDisplay = document.getElementById('variantNotesDisplay');
            if (variantNotesDisplay) {
                const dashes = '-----------------------------------';
                if (node.comment) {
                    variantNotesDisplay.textContent = dashes + ' ' + node.comment;
                } else {
                    variantNotesDisplay.textContent = dashes;
                }
                variantNotesDisplay.style.color = '#ffd700';
            }

            // Update all comments display
            updateAllCommentsDisplay();
        }

        /**
         * Collect all comments from the move tree
         */
        function collectAllComments(rootNode) {
            const comments = [];

            function traverse(node, isMainLine = true) {
                if (!node) return;

                // Add comment if this node has one
                if (node.comment && node.san) {
                    comments.push({
                        moveNumber: node.moveNumber,
                        san: node.san,
                        annotation: node.annotation || '',
                        comment: node.comment,
                        nodeId: node.nodeId,
                        isBlackMove: node.isBlackMove,
                        isMainLine: isMainLine
                    });
                }

                // Traverse children
                if (node.children && node.children.length > 0) {
                    // First child is main line
                    traverse(node.children[0], isMainLine);
                    // Other children are variations
                    for (let i = 1; i < node.children.length; i++) {
                        traverse(node.children[i], false);
                    }
                }
            }

            traverse(rootNode);
            return comments;
        }

        /**
         * Update the all comments display panel
         */
        function updateAllCommentsDisplay() {
            const container = document.getElementById('allCommentsContainer');
            if (!container) return;

            container.innerHTML = '';

            // Get comments from move tree or flat array
            let comments = [];

            if (window.moveTree) {
                comments = collectAllComments(window.moveTree);
            } else if (window.studyReportComments) {
                // Fallback to flat comments array
                Object.keys(window.studyReportComments).forEach(index => {
                    const comment = window.studyReportComments[index];
                    if (comment) {
                        const moveNum = Math.floor(parseInt(index) / 2) + 1;
                        const isBlack = parseInt(index) % 2 === 1;
                        comments.push({
                            moveNumber: moveNum,
                            san: '',
                            annotation: '',
                            comment: comment,
                            nodeId: null,
                            isBlackMove: isBlack,
                            isMainLine: true,
                            flatIndex: parseInt(index)
                        });
                    }
                });
            }

            if (comments.length === 0) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';

            // Get current node ID for highlighting
            const currentNodeId = window.currentMoveNode ? window.currentMoveNode.nodeId : null;
            const currentFlatIndex = window.studyReportPositionIndex;

            comments.forEach((c, idx) => {
                const commentDiv = document.createElement('div');
                commentDiv.style.padding = '4px 8px';
                commentDiv.style.marginBottom = '4px';
                commentDiv.style.borderRadius = '3px';
                commentDiv.style.cursor = 'pointer';

                // Check if this is the current comment
                const isCurrent = (c.nodeId && c.nodeId === currentNodeId) ||
                                  (c.flatIndex !== undefined && c.flatIndex === currentFlatIndex);

                if (isCurrent) {
                    commentDiv.style.background = '#0f3460';
                    commentDiv.style.borderLeft = '3px solid #ffd700';
                } else {
                    commentDiv.style.background = 'transparent';
                    commentDiv.style.borderLeft = '3px solid transparent';
                }

                // Build move label: "7... d5" or "8. exd5"
                let moveLabel = c.moveNumber + (c.isBlackMove ? '... ' : '. ');
                if (c.san) {
                    moveLabel += c.san + c.annotation;
                }

                // Create content - use annotation color if available
                const labelSpan = document.createElement('span');
                const annotationColor = getAnnotationColor(c.annotation);
                labelSpan.style.color = annotationColor || (c.isMainLine ? '#00d4ff' : '#888');
                labelSpan.style.fontWeight = 'bold';
                labelSpan.textContent = '{' + moveLabel.trim() + '} ';

                const commentSpan = document.createElement('span');
                commentSpan.style.color = '#ffd700';
                commentSpan.textContent = c.comment;

                commentDiv.appendChild(labelSpan);
                commentDiv.appendChild(commentSpan);

                // Click to jump to this position
                if (c.nodeId) {
                    commentDiv.onclick = function() {
                        jumpToNode(c.nodeId);
                    };
                }

                container.appendChild(commentDiv);

                // Scroll current into view
                if (isCurrent) {
                    commentDiv.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                }
            });
        }

        /**
         * Navigate to the start position (root node)
         */
        function jumpToRoot() {
            if (!window.moveTree) return;

            window.currentMoveNode = null;

            // Update board position
            if (window.board2) {
                window.board2.position(window.moveTree.fen);
            }

            // Clear highlighting
            document.querySelectorAll('.move-san.current, .variation-move.current').forEach(el => {
                el.classList.remove('current');
            });

            // Restore full board opacity when at root
            const boardContainer = document.getElementById('myBoard2');
            if (boardContainer) {
                boardContainer.style.opacity = '1';
            }

            // Update other displays
            updateMaterialDisplay(window.moveTree.fen);

            // Update variant notes display
            const variantNotesDisplay = document.getElementById('variantNotesDisplay');
            if (variantNotesDisplay) {
                variantNotesDisplay.textContent = '-----------------------------------';
                variantNotesDisplay.style.color = '#ffd700';
            }

            // Update all comments display
            updateAllCommentsDisplay();
        }

        /**
         * Calculate captured pieces and material advantage from FEN
         */
        function getCapturedPieces(fen) {
            const board = fen.split(' ')[0];

            // Starting counts
            const start = { P: 8, R: 2, N: 2, B: 2, Q: 1, p: 8, r: 2, n: 2, b: 2, q: 1 };

            // Current counts
            const current = {};
            for (const char of board) {
                if ('PRNBQprnbq'.includes(char)) {
                    current[char] = (current[char] || 0) + 1;
                }
            }

            // Piece symbols and values
            const symbols = { P: '‚ôô', R: '‚ôñ', N: '‚ôò', B: '‚ôó', Q: '‚ôï', p: '‚ôü', r: '‚ôú', n: '‚ôû', b: '‚ôù', q: '‚ôõ' };
            const values = { p: 1, n: 3, b: 3, r: 5, q: 9 };

            // Order: pawns first, then minor, then major
            const order = ['p', 'n', 'b', 'r', 'q'];

            const whiteCaptured = []; // pieces white captured (black pieces missing)
            const blackCaptured = []; // pieces black captured (white pieces missing)
            let whiteMaterial = 0, blackMaterial = 0;

            for (const pieceType of order) {
                const whitePiece = pieceType.toUpperCase();
                const blackPiece = pieceType;

                // Missing white pieces (captured by black)
                const missingWhite = start[whitePiece] - (current[whitePiece] || 0);
                for (let i = 0; i < missingWhite; i++) {
                    blackCaptured.push(symbols[whitePiece]);
                    blackMaterial += values[pieceType];
                }

                // Missing black pieces (captured by white)
                const missingBlack = start[blackPiece] - (current[blackPiece] || 0);
                for (let i = 0; i < missingBlack; i++) {
                    whiteCaptured.push(symbols[blackPiece]);
                    whiteMaterial += values[pieceType];
                }
            }

            const diff = whiteMaterial - blackMaterial;

            return {
                whiteCaptured,
                blackCaptured,
                advantage: Math.abs(diff),
                advantageSide: diff > 0 ? 'white' : diff < 0 ? 'black' : null
            };
        }

        /**
         * Update material display above the board
         */
        function updateMaterialDisplay(fen) {
            const whiteCapturedEl = document.getElementById('whiteCaptured');
            const blackCapturedEl = document.getElementById('blackCaptured');
            const whiteAdvantageEl = document.getElementById('whiteAdvantage');
            const blackAdvantageEl = document.getElementById('blackAdvantage');

            if (!whiteCapturedEl || !blackCapturedEl) return;

            const material = getCapturedPieces(fen);

            // Display captured pieces
            whiteCapturedEl.textContent = material.whiteCaptured.join('');
            blackCapturedEl.textContent = material.blackCaptured.join('');

            // Clear advantages first
            whiteAdvantageEl.textContent = '';
            blackAdvantageEl.textContent = '';

            // Show advantage on the appropriate side
            if (material.advantageSide === 'white' && material.advantage > 0) {
                whiteAdvantageEl.textContent = `+${material.advantage}`;
            } else if (material.advantageSide === 'black' && material.advantage > 0) {
                blackAdvantageEl.textContent = `+${material.advantage}`;
            }
        }

        /**
         * Update board2 move indicator display
         */
        function updateBoard2MoveIndicator(index) {
            const indicator = document.getElementById('board2MoveIndicator');
            const positionCount = document.getElementById('board2PositionCount');
            const lichessLink = document.getElementById('lichessBoard2Link');

            if (!indicator || !window.studyReportPositions) return;

            const total = window.studyReportPositions.length;
            if (positionCount) {
                positionCount.textContent = `${index + 1}/${total}`;
            }

            let moveNotation = 'Start';
            if (index > 0) {
                const moveNumber = Math.ceil(index / 2);
                const isWhiteMove = index % 2 === 1;
                moveNotation = isWhiteMove ? `${moveNumber}.` : `${moveNumber}...`;
            }
            indicator.textContent = moveNotation;

            // Check if this move is a mistake/blunder and highlight accordingly
            indicator.style.background = 'transparent';
            indicator.style.padding = '4px 8px';
            indicator.style.borderRadius = '4px';

            if (window.loadedMistakes && Object.keys(window.loadedMistakes).length > 0) {
                const severity = window.loadedMistakes[moveNotation];
                if (severity === 'BLUNDER') {
                    indicator.style.background = '#ff6b6b'; // Red for blunder
                    indicator.style.color = '#1a1a2e';
                } else if (severity === 'MISTAKE') {
                    indicator.style.background = '#ffa94d'; // Orange for mistake
                    indicator.style.color = '#1a1a2e';
                } else if (severity === 'INACCURACY') {
                    indicator.style.background = '#51cf66'; // Green for inaccuracy
                    indicator.style.color = '#1a1a2e';
                } else {
                    indicator.style.color = '#eee';
                }
            } else {
                indicator.style.color = '#eee';
            }

            // Update Lichess link
            if (lichessLink && window.studyReportPositions[index]) {
                const position = window.studyReportPositions[index];
                const colorToMove = (index % 2 === 0) ? 'w' : 'b';
                let fen = position.includes(' ') ? position : `${position} ${colorToMove} KQkq - 0 1`;
                lichessLink.href = `https://lichess.org/analysis/${fen.replace(/ /g, '_')}`;
            }

            // Update material display
            if (window.studyReportPositions[index]) {
                updateMaterialDisplay(window.studyReportPositions[index]);
            }

            // Update variant notes display with PGN comment for current position
            const variantNotesDisplay = document.getElementById('variantNotesDisplay');
            if (variantNotesDisplay) {
                const comment = window.studyReportComments ? window.studyReportComments[index] : null;
                const dashes = '-----------------------------------';
                if (comment) {
                    variantNotesDisplay.textContent = dashes + ' ' + comment;
                } else {
                    variantNotesDisplay.textContent = dashes;
                }
                variantNotesDisplay.style.color = '#ffd700';
            }

            // Update all comments display
            updateAllCommentsDisplay();
        }

        function board2NextMove() {
            // Tree-based navigation (if move tree is active)
            if (window.moveTree) {
                if (window.currentMoveNode === null) {
                    // At start position, go to first move
                    if (window.moveTree.children && window.moveTree.children.length > 0) {
                        jumpToNode(window.moveTree.children[0].nodeId);
                    }
                } else if (window.currentMoveNode.children && window.currentMoveNode.children.length > 0) {
                    // Go to first child (main continuation)
                    jumpToNode(window.currentMoveNode.children[0].nodeId);
                }
                // If no children, stay at current position (end of line)
                return;
            }

            // Fallback: flat array navigation
            if (!window.studyReportPositions || window.studyReportPositions.length === 0) return;
            window.studyReportPositionIndex++;
            if (window.studyReportPositionIndex >= window.studyReportPositions.length) {
                window.studyReportPositionIndex = window.studyReportPositions.length - 1;
            }
            if (window.board2) {
                window.board2.position(window.studyReportPositions[window.studyReportPositionIndex]);
            }
            updateBoard2MoveIndicator(window.studyReportPositionIndex);
        }

        function board2PrevMove() {
            // Tree-based navigation (if move tree is active)
            if (window.moveTree) {
                if (window.currentMoveNode === null) {
                    // Already at start, do nothing
                    return;
                } else if (window.currentMoveNode.parent) {
                    if (window.currentMoveNode.parent.nodeId === 'root') {
                        // Going back to root (start position)
                        jumpToRoot();
                    } else {
                        // Go to parent node
                        jumpToNode(window.currentMoveNode.parent.nodeId);
                    }
                }
                return;
            }

            // Fallback: flat array navigation
            if (!window.studyReportPositions || window.studyReportPositions.length === 0) return;
            window.studyReportPositionIndex--;
            if (window.studyReportPositionIndex < 0) {
                window.studyReportPositionIndex = 0;
            }
            if (window.board2) {
                window.board2.position(window.studyReportPositions[window.studyReportPositionIndex]);
            }
            updateBoard2MoveIndicator(window.studyReportPositionIndex);
        }

        /**
         * Extract and display game info from report content
         */
        function updateCurrentGameInfo(reportContent) {
            const gameInfoSpan = document.getElementById('currentGameInfo');
            if (!gameInfoSpan) return;

            // Look for "Game: white: ... vs black: ..." pattern (case-insensitive, flexible spacing)
            const gameMatch = reportContent.match(/Game:\s*white:\s*(.+?)\s*\((\d+)\)\s*vs\s*black:\s*(.+?)\s*\((\d+)\)\s*\|\s*(\w+)\s*\(([^)]+)\)\s*\|\s*Result:\s*(\w+)(?:\s*\|\s*(https?:\/\/[^\s\n]+))?/i);

            if (gameMatch) {
                const [, white, whiteRating, black, blackRating, timeClass, timeControl, result, url] = gameMatch;
                let info = `Game: ${white.trim()} (${whiteRating}) vs ${black.trim()} (${blackRating}) | ${timeClass} (${timeControl}) | ${result}`;
                if (url) info += ` | ${url}`;
                gameInfoSpan.textContent = info;
                gameInfoSpan.title = info; // Full text on hover
            } else {
                gameInfoSpan.textContent = '';
            }
        }

        /**
         * Load analysis report from content
         */
        function loadStudyReportFromContent(clipboardText, sourceName = 'clipboard') {
            if (!clipboardText || clipboardText.trim() === '') {
                log('No content to load', 'warning');
                return;
            }

            window.studyReportRawText = clipboardText;

            // Show report container and display content (use the original analysisReportContainer)
            const reportContainer = document.getElementById('analysisReportContainer');
            const reportText = document.getElementById('analysisReportText');

            if (reportContainer && reportText) {
                reportContainer.style.display = 'block';
                reportText.textContent = clipboardText;
                // Update game info display
                updateCurrentGameInfo(clipboardText);
                // Update filename display - use source filename if it's a .txt file
                const filenameDisplay = document.getElementById('reportFilenameDisplay');
                if (filenameDisplay) {
                    if (sourceName && sourceName !== 'clipboard' && sourceName.endsWith('.txt')) {
                        filenameDisplay.textContent = 'üìÅ ' + sourceName;
                    } else {
                        updateReportFilenameDisplay();
                    }
                }
                // Rescan FEN/PGN variants with new report content
                window.fenVariants = [];
                window.pgnVariants = [];
                window.allVariants = [];
                if (typeof window.scanReportForFenVariants === 'function') {
                    window.scanReportForFenVariants();
                }
                if (typeof window.scanReportForPgnVariants === 'function') {
                    window.scanReportForPgnVariants();
                }
                if (document.getElementById('currentFenMoves')) {
                    document.getElementById('currentFenMoves').textContent = '';
                }
                if (document.getElementById('variantIndexDisplay')) {
                    document.getElementById('variantIndexDisplay').textContent = '';
                }
            }

            // Extract PGN from report and load to board2
            let pgnMatch = clipboardText.match(/GAME PGN[\s\S]*?-{5,}\s*(1\.[^\n]+)/);
            if (pgnMatch && pgnMatch[1]) {
                let pgnText = pgnMatch[1].trim();
                pgnText = pgnText.replace(/\s+/g, ' ').trim();

                // Also populate the pgnInput textarea so "Reload Game from Report" works
                const pgnTextarea = document.getElementById('pgnInput');
                if (pgnTextarea) {
                    pgnTextarea.value = pgnText;
                }

                if (typeof window.parsePgnToPositions === 'function') {
                    window.studyReportPositions = window.parsePgnToPositions(pgnText);
                    window.studyReportPositionIndex = 0;

                    if (window.studyReportPositions && window.studyReportPositions.length > 0) {
                        if (window.board2) {
                            window.board2.position(window.studyReportPositions[0]);
                            updateBoard2MoveIndicator(0);
                        }
                    }
                }
            }

            log(`Loaded report from ${sourceName}`, 'success');
        }

        /**
         * Open report files modal
         */
        function openReportFilesModal() {
            const modal = document.getElementById('reportFilesModal');
            const filesList = document.getElementById('reportFilesList');

            if (!modal || !filesList) return;

            filesList.innerHTML = '';

            if (!window.loadedReportFiles || window.loadedReportFiles.length === 0) {
                filesList.innerHTML = '<p style="color: #888;">No report files loaded. Use "Select Reports Folder" to load files.</p>';
                modal.style.display = 'block';
                return;
            }

            window.loadedReportFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid #0f3460; cursor: pointer; border-radius: 4px;';
                fileItem.innerHTML = `
                    <span style="flex: 1;">${file.name}</span>
                    <button style="background: #00d4ff; color: #1a1a2e; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-weight: bold;">Load</button>
                `;

                fileItem.addEventListener('mouseenter', () => fileItem.style.background = '#0f3460');
                fileItem.addEventListener('mouseleave', () => fileItem.style.background = 'transparent');

                fileItem.addEventListener('click', async () => {
                    try {
                        let content;
                        if (typeof file.text === 'function') {
                            content = await file.text();
                        } else if (file.content) {
                            content = file.content;
                        }

                        if (content) {
                            loadStudyReportFromContent(content, file.name);
                            modal.style.display = 'none';
                        }
                    } catch (err) {
                        console.error('Error loading file:', err);
                        alert('Failed to load file: ' + file.name);
                    }
                });

                filesList.appendChild(fileItem);
            });

            modal.style.display = 'block';
        }

        // Initialize on load
        window.onload = () => {
            log('Chess Analyzer loaded', 'info');
            if (typeof AnalysisChess !== 'undefined') {
                log('AnalysisChess module loaded', 'success');
            }
            initStockfish();

            // Show variation adder when PGN is pasted
            const pgnInput = document.getElementById('pgnInput');
            if (pgnInput) {
                pgnInput.addEventListener('input', () => {
                    const variationAdder = document.getElementById('variation-adder');
                    if (pgnInput.value.trim().length > 10) {
                        variationAdder.style.display = 'block';
                    }
                });
            }

            // =========================================================
            // AUTO-PLAY FUNCTIONALITY
            // =========================================================
            const autoPlayToggle = document.getElementById('dragScrollToggle');
            const autoPlayLabel = document.getElementById('dragScrollLabel');
            let autoPlayInterval = null;
            const nextButton = document.getElementById('board2NextMove');

            // Toggle auto-play mode
            autoPlayToggle.addEventListener('change', function() {
                if (this.checked) {
                    // Start auto-play loop
                    autoPlayLabel.classList.add('active');
                    autoPlayInterval = setInterval(function() {
                        nextButton.click();
                    }, 400);
                } else {
                    // Stop auto-play loop
                    autoPlayLabel.classList.remove('active');
                    if (autoPlayInterval) {
                        clearInterval(autoPlayInterval);
                        autoPlayInterval = null;
                    }
                }
            });

            // Reset button - turns off auto-play and resets to move #1
            document.getElementById('resetAutoPlayBtn').addEventListener('click', function() {
                // Turn off auto-play if it's on
                if (autoPlayToggle.checked) {
                    autoPlayToggle.checked = false;
                    autoPlayLabel.classList.remove('active');
                    if (autoPlayInterval) {
                        clearInterval(autoPlayInterval);
                        autoPlayInterval = null;
                    }
                }

                // Reset board to move #1
                if (window.studyReportPositions && window.studyReportPositions.length > 0) {
                    window.studyReportPositionIndex = 0;
                    if (window.board2) {
                        window.board2.position(window.studyReportPositions[0]);
                    }
                    updateBoard2MoveIndicator(0);
                }
            });

            // Toggle report button (original)
            document.getElementById('toggleReportBtn').addEventListener('click', function() {
                const reportText = document.getElementById('analysisReportText');
                const toggleBtn = document.getElementById('toggleReportBtn');

                if (reportText.style.display === 'none') {
                    reportText.style.display = 'block';
                    toggleBtn.textContent = 'Hide Report';
                } else {
                    reportText.style.display = 'none';
                    toggleBtn.textContent = 'Show Report';
                }
            });

            // Enter key triggers Chess.com fetch
            document.getElementById('chesscom-username').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    fetchChesscomGames();
                }
            });

            // =========================================================
            // STUDY TOOL INITIALIZATION
            // =========================================================

            // Initialize Board2
            window.board2 = Chessboard('myBoard2', {
                draggable: true,
                dropOffBoard: 'snapback',
                position: 'start',
                snapbackSpeed: 500,
                snapSpeed: 100,
                pieceTheme: pieceThemePath
            });

            // Force refresh board images after short delay (fixes Vercel deployment image loading)
            setTimeout(function() {
                if (window.board2) {
                    window.board2.position('start');
                }
            }, 500);

            // Board2 Navigation
            const board2NextBtn = document.getElementById('board2NextMove');
            if (board2NextBtn) {
                board2NextBtn.addEventListener('click', board2NextMove);
            }

            const board2PrevBtn = document.getElementById('board2PrevMove');
            if (board2PrevBtn) {
                board2PrevBtn.addEventListener('click', board2PrevMove);
            }

            // Flip Board 2
            const flipBoard2 = document.getElementById('flip_board2');
            if (flipBoard2) {
                flipBoard2.addEventListener('click', function() {
                    log('Flipping board 2', 'info');
                    window.board2.flip();
                });
            }

            // Load PGN from Clipboard
            const loadPgnFromClipboardBtn = document.getElementById('loadPgnFromClipboard');
            if (loadPgnFromClipboardBtn) {
                loadPgnFromClipboardBtn.addEventListener('click', async function() {
                    try {
                        const clipboardText = await navigator.clipboard.readText();
                        if (!clipboardText || clipboardText.trim() === '') {
                            alert('Clipboard is empty. Please copy a PGN first.');
                            return;
                        }

                        let pgnText = clipboardText.trim();
                        pgnText = pgnText.split('\n')
                            .filter(line => !line.trim().startsWith('['))
                            .join(' ')
                            .replace(/\s+/g, ' ')
                            .trim();

                        if (!/\d+\./.test(pgnText)) {
                            alert('Clipboard does not contain valid PGN.');
                            return;
                        }

                        if (typeof window.parsePgnToPositions === 'function') {
                            window.studyReportPositions = window.parsePgnToPositions(pgnText);
                            window.studyReportPositionIndex = 0;

                            if (window.studyReportPositions && window.studyReportPositions.length > 0) {
                                window.board2.position(window.studyReportPositions[0]);
                                updateBoard2MoveIndicator(0);
                                log(`Loaded ${window.studyReportPositions.length} positions from clipboard`, 'success');
                            }
                        }
                    } catch (err) {
                        console.error('Failed to read clipboard:', err);
                        alert('Could not read clipboard. Please check permissions.');
                    }
                });
            }

            // Reload Game from Report Button
            const reloadGameFromReportBtn = document.getElementById('reloadGameFromReport');
            if (reloadGameFromReportBtn) {
                reloadGameFromReportBtn.addEventListener('click', function() {
                    const pgnTextarea = document.getElementById('pgnInput');
                    if (!pgnTextarea || !pgnTextarea.value.trim()) {
                        alert('No game PGN available. Please analyze a game first.');
                        return;
                    }

                    let pgnText = pgnTextarea.value.trim();

                    // Clean the PGN
                    if (typeof cleanPgn === 'function') {
                        pgnText = cleanPgn(pgnText);
                    } else {
                        pgnText = pgnText.split('\n')
                            .filter(line => !line.trim().startsWith('['))
                            .join(' ')
                            .replace(/\s+/g, ' ')
                            .trim();
                    }

                    if (typeof window.parsePgnToPositions === 'function') {
                        window.studyReportPositions = window.parsePgnToPositions(pgnText);
                        window.studyReportPositionIndex = 0;

                        if (window.studyReportPositions && window.studyReportPositions.length > 0) {
                            if (window.board2) {
                                window.board2.position(window.studyReportPositions[0]);
                                updateBoard2MoveIndicator(0);
                            }
                            // Reset variant displays
                            document.getElementById('currentFenMoves').textContent = '';
                            document.getElementById('variantIndexDisplay').textContent = '';
                            window.currentVariantType = null;
                            log(`Reloaded ${window.studyReportPositions.length} positions from original game`, 'success');
                        } else {
                            alert('Could not parse positions from the game PGN.');
                        }
                    } else {
                        alert('PGN parser not available.');
                    }
                });
            }

            // Next FEN Variant Button
            window.fenVariants = [];
            window.currentFenVariantIndex = 0;
            window.pgnVariants = [];
            window.currentPgnVariantIndex = 0;
            window.currentVariantType = null; // 'fen' or 'pgn'

            // Scan report for regular PGN blocks (not FEN variants)
            window.scanReportForPgnVariants = function() {
                const reportText = document.getElementById('analysisReportText');
                const textarea = document.getElementById('reportEditTextarea');
                const content = window.isReportEditMode ? textarea.value : reportText.textContent;

                window.pgnVariants = [];
                // Match PGN that starts with move number and doesn't have [Variant or [FEN before it
                // Look for lines starting with move numbers like "1. e4" or "14. Qe2"
                const lines = content.split('\n');
                let currentPgn = '';
                let inPgn = false;
                let pgnStartLineIndex = -1;

                // Helper function to get notes from 2 lines before a given index
                function getNotesFromLinesBefore(lineIndex) {
                    // Look back up to 2 lines for non-empty content
                    for (let k = lineIndex - 1; k >= Math.max(0, lineIndex - 2); k--) {
                        const prevLine = lines[k].trim();
                        // Skip empty lines and lines starting with [ or containing FEN/Variant
                        if (prevLine && !prevLine.startsWith('[') && !prevLine.includes('[FEN') && !prevLine.includes('[Variant') && !/^\d+\./.test(prevLine)) {
                            // Remove curly braces if present
                            return prevLine.replace(/^\{|\}$/g, '');
                        }
                    }
                    return '';
                }

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();

                    // Skip FEN variant blocks
                    if (line.includes('[Variant "From Position"]') || line.includes('[FEN "')) {
                        if (currentPgn.trim()) {
                            const notes = getNotesFromLinesBefore(pgnStartLineIndex);
                            window.pgnVariants.push({ pgn: currentPgn.trim(), notes: notes });
                        }
                        currentPgn = '';
                        inPgn = false;
                        pgnStartLineIndex = -1;
                        // Skip until we find a non-PGN line
                        while (i < lines.length && (lines[i].includes('[') || /^\d+\./.test(lines[i].trim()))) {
                            i++;
                        }
                        continue;
                    }

                    // Check if line starts with move number (e.g., "1. e4" or "14. Qe2")
                    if (/^\d+\.\s*[A-Za-z]/.test(line)) {
                        if (!inPgn && currentPgn.trim()) {
                            const notes = getNotesFromLinesBefore(pgnStartLineIndex);
                            window.pgnVariants.push({ pgn: currentPgn.trim(), notes: notes });
                            currentPgn = '';
                        }
                        if (!inPgn) {
                            pgnStartLineIndex = i;
                        }
                        inPgn = true;
                        currentPgn += line + ' ';
                    } else if (inPgn && /^[A-Za-z0-9]/.test(line) && !line.startsWith('*') && !line.startsWith('[')) {
                        // Continue PGN on next line
                        currentPgn += line + ' ';
                    } else if (inPgn && line === '') {
                        // End of PGN block
                        if (currentPgn.trim()) {
                            const notes = getNotesFromLinesBefore(pgnStartLineIndex);
                            window.pgnVariants.push({ pgn: currentPgn.trim(), notes: notes });
                        }
                        currentPgn = '';
                        inPgn = false;
                        pgnStartLineIndex = -1;
                    }
                }
                // Don't forget last PGN if file doesn't end with empty line
                if (currentPgn.trim()) {
                    const notes = getNotesFromLinesBefore(pgnStartLineIndex);
                    window.pgnVariants.push({ pgn: currentPgn.trim(), notes: notes });
                }

                window.currentPgnVariantIndex = 0;
                console.log('Total PGN variants found:', window.pgnVariants.length);
                return window.pgnVariants.length;
            };

            window.loadCurrentPgnVariant = function() {
                if (window.pgnVariants.length === 0) return;

                const variant = window.pgnVariants[window.currentPgnVariantIndex];
                const pgn = variant.pgn;
                window.currentVariantType = 'pgn';

                window.studyReportPositions = window.parsePgnToPositions(pgn);
                window.studyReportPositionIndex = 0;

                if (window.studyReportPositions && window.studyReportPositions.length > 0) {
                    window.board2.position(window.studyReportPositions[0]);
                    updateBoard2MoveIndicator(0);
                }

                // Update variant index display
                const indexSpan = document.getElementById('variantIndexDisplay');
                if (indexSpan) {
                    indexSpan.textContent = `PGN ${window.currentPgnVariantIndex + 1}/${window.pgnVariants.length}`;
                }

                // Update moves span (limited to 7 chars)
                const movesSpan = document.getElementById('currentFenMoves');
                if (movesSpan) {
                    const movesDisplay = pgn.length > 7 ? pgn.substring(0, 7) : pgn;
                    movesSpan.textContent = movesDisplay;
                }

                // Update notes display
                const notesSpan = document.getElementById('variantNotesDisplay');
                if (notesSpan) {
                    notesSpan.textContent = variant.notes || '';
                }
            };

            window.scanReportForFenVariants = function() {
                const reportText = document.getElementById('analysisReportText');
                const textarea = document.getElementById('reportEditTextarea');
                const content = window.isReportEditMode ? textarea.value : reportText.textContent;

                window.fenVariants = [];
                const lines = content.split('\n');
                let pendingVariant = false;  // Track if we saw [Variant...] on previous line
                let variantLineIndex = -1;   // Track line index where [Variant...] was found

                // Helper function to get notes from 2 lines before a given index
                function getNotesFromLinesBefore(lineIndex) {
                    // Look back up to 2 lines for non-empty content
                    for (let k = lineIndex - 1; k >= Math.max(0, lineIndex - 2); k--) {
                        const prevLine = lines[k].trim();
                        // Skip empty lines and lines starting with [ or containing FEN/Variant
                        if (prevLine && !prevLine.startsWith('[') && !prevLine.includes('[FEN') && !prevLine.includes('[Variant')) {
                            // Remove curly braces if present
                            return prevLine.replace(/^\{|\}$/g, '');
                        }
                    }
                    return '';
                }

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();

                    // Check for [Variant...][FEN...] on same line
                    const combinedMatch = line.match(/\[Variant\s+"From\s+Position"\]\s*\[FEN\s+"([^"]+)"\]/);
                    if (combinedMatch) {
                        // Look back for notes
                        const notes = getNotesFromLinesBefore(i);

                        // Look ahead for moves on next line(s)
                        let moves = '';
                        for (let j = i + 1; j < lines.length; j++) {
                            const nextLine = lines[j].trim();
                            if (nextLine.match(/^\d+\./)) {
                                moves = nextLine;
                                break;
                            }
                            // Stop if we hit another block
                            if (nextLine.startsWith('[Variant') || nextLine.startsWith('[FEN')) break;
                        }

                        window.fenVariants.push({
                            notes: notes,
                            fen: combinedMatch[1],
                            moves: moves
                        });
                        console.log('Found FEN variant:', combinedMatch[1], 'Notes:', notes, 'Moves:', moves);
                        pendingVariant = false;
                        continue;
                    }

                    // Check for [Variant "From Position"] alone on a line
                    if (line.match(/\[Variant\s+"From\s+Position"\]/)) {
                        pendingVariant = true;
                        variantLineIndex = i;
                        continue;
                    }

                    // Check for [FEN "..."] after we saw [Variant...]
                    const fenOnlyMatch = line.match(/\[FEN\s+"([^"]+)"\]/);
                    if (fenOnlyMatch && pendingVariant) {
                        // Look back for notes (from the [Variant...] line)
                        const notes = getNotesFromLinesBefore(variantLineIndex);

                        // Look ahead for moves on next line(s)
                        let moves = '';
                        for (let j = i + 1; j < lines.length; j++) {
                            const nextLine = lines[j].trim();
                            if (nextLine.match(/^\d+\./)) {
                                moves = nextLine;
                                break;
                            }
                            // Stop if we hit another block
                            if (nextLine.startsWith('[Variant') || nextLine.startsWith('[FEN')) break;
                        }

                        window.fenVariants.push({
                            notes: notes,
                            fen: fenOnlyMatch[1],
                            moves: moves
                        });
                        console.log('Found FEN variant (split lines):', fenOnlyMatch[1], 'Notes:', notes, 'Moves:', moves);
                        pendingVariant = false;
                        continue;
                    }

                    // Reset pendingVariant if we hit a non-matching line (but not empty lines)
                    if (pendingVariant && line && !line.startsWith('[')) {
                        pendingVariant = false;
                    }
                }
                window.currentFenVariantIndex = 0;
                console.log('Total FEN variants found:', window.fenVariants.length);
                return window.fenVariants.length;
            };

            window.loadCurrentFenVariant = function() {
                if (window.fenVariants.length === 0) return;

                const variant = window.fenVariants[window.currentFenVariantIndex];
                const pgnString = `[Variant "From Position"]\n[FEN "${variant.fen}"]\n\n${variant.moves}`;
                window.currentVariantType = 'fen';

                window.studyReportPositions = window.parsePgnToPositions(pgnString);
                window.studyReportPositionIndex = 0;

                if (window.studyReportPositions && window.studyReportPositions.length > 0) {
                    window.board2.position(window.studyReportPositions[0]);
                    updateBoard2MoveIndicator(0);
                }

                // Update variant index display
                const indexSpan = document.getElementById('variantIndexDisplay');
                if (indexSpan) {
                    indexSpan.textContent = `FEN ${window.currentFenVariantIndex + 1}/${window.fenVariants.length}`;
                }

                // Update moves span (limited to 7 chars)
                const movesSpan = document.getElementById('currentFenMoves');
                if (movesSpan) {
                    const movesDisplay = variant.moves.length > 7 ? variant.moves.substring(0, 7) : variant.moves;
                    movesSpan.textContent = movesDisplay;
                }

                // Update notes display
                const notesSpan = document.getElementById('variantNotesDisplay');
                if (notesSpan) {
                    notesSpan.textContent = variant.notes || '';
                }
            };

            // Combined FEN/PGN variants array (in document order)
            window.allVariants = [];
            window.currentVariantIndex = 0;
            window.allFileSections = [];  // Track all [filename.txt] sections
            window.currentFileSectionIndex = 0;

            // Scan report for ALL variants (FEN and PGN) in document order
            window.scanReportForAllVariants = function() {
                const reportText = document.getElementById('analysisReportText');
                const textarea = document.getElementById('reportEditTextarea');
                const content = window.isReportEditMode ? textarea.value : reportText.textContent;

                window.allVariants = [];
                window.allFileSections = [];
                const lines = content.split('\n');
                let pendingVariant = false;
                let variantLineIndex = -1;

                // Track current game info as we scan
                let currentGameInfo = '';
                let currentFileName = '';
                let currentFileSectionIndex = -1;

                // Helper function to get notes from 2 lines before a given index
                function getNotesFromLinesBefore(lineIndex) {
                    for (let k = lineIndex - 1; k >= Math.max(0, lineIndex - 2); k--) {
                        const prevLine = lines[k].trim();
                        if (prevLine && !prevLine.startsWith('[') && !prevLine.includes('[FEN') && !prevLine.includes('[Variant') && !/^\d+\./.test(prevLine)) {
                            return prevLine.replace(/^\{|\}$/g, '');
                        }
                    }
                    return '';
                }

                // Track PGN state
                let currentPgn = '';
                let inPgn = false;
                let pgnStartLineIndex = -1;

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();

                    // Check for FILE: header (from appended reports)
                    const fileMatch = line.match(/^FILE:\s*(.+\.txt)$/i);
                    if (fileMatch) {
                        currentFileName = fileMatch[1];
                        currentGameInfo = ''; // Reset game info for new file
                        currentFileSectionIndex = window.allFileSections.length;
                        window.allFileSections.push({
                            fileName: currentFileName,
                            lineIndex: i,
                            displayName: currentFileName.replace(/\.txt$/i, '').replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase())
                        });
                        continue;
                    }

                    // Check for [filename.txt] bracket format (study files)
                    const bracketFileMatch = line.match(/^\[([^\]]+\.txt)\]$/i);
                    if (bracketFileMatch) {
                        currentFileName = bracketFileMatch[1];
                        currentGameInfo = ''; // Reset game info for new file
                        currentFileSectionIndex = window.allFileSections.length;
                        window.allFileSections.push({
                            fileName: currentFileName,
                            lineIndex: i,
                            displayName: currentFileName.replace(/\.txt$/i, '').replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase())
                        });
                        continue;
                    }

                    // Check for Game: line (case-insensitive)
                    const gameMatch = line.match(/^Game:\s*white:\s*(.+?)\s*\((\d+)\)\s*vs\s*black:\s*(.+?)\s*\((\d+)\)\s*\|\s*(\w+)\s*\(([^)]+)\)\s*\|\s*Result:\s*(\w+)(?:\s*\|\s*(https?:\/\/[^\s]+))?/i);
                    if (gameMatch) {
                        const [, white, whiteRating, black, blackRating, timeClass, timeControl, result, url] = gameMatch;
                        currentGameInfo = `${white.trim()} (${whiteRating}) vs ${black.trim()} (${blackRating}) | ${timeClass} (${timeControl}) | ${result}`;
                        if (url) currentGameInfo += ` | ${url}`;
                        continue;
                    }

                    // Fallback: Check for "Loss as White" or "Win as Black" patterns
                    const resultMatch = line.match(/^(Win|Loss|Draw)\s+as\s+(White|Black)$/i);
                    if (resultMatch && !currentGameInfo) {
                        currentGameInfo = `${resultMatch[1]} as ${resultMatch[2]}`;
                        continue;
                    }

                    // Check for [Variant...][FEN...] on same line (FEN variant)
                    const combinedMatch = line.match(/\[Variant\s+"From\s+Position"\]\s*\[FEN\s+"([^"]+)"\]/);
                    if (combinedMatch) {
                        // Save any pending PGN first
                        if (currentPgn.trim()) {
                            const notes = getNotesFromLinesBefore(pgnStartLineIndex);
                            window.allVariants.push({ type: 'pgn', pgn: currentPgn.trim(), notes: notes, lineIndex: pgnStartLineIndex, gameInfo: currentGameInfo, fileName: currentFileName, fileSectionIndex: currentFileSectionIndex });
                            currentPgn = '';
                            inPgn = false;
                        }

                        const notes = getNotesFromLinesBefore(i);
                        let moves = '';
                        for (let j = i + 1; j < lines.length; j++) {
                            const nextLine = lines[j].trim();
                            if (nextLine.match(/^\d+\./)) {
                                moves = nextLine;
                                break;
                            }
                            if (nextLine.startsWith('[Variant') || nextLine.startsWith('[FEN')) break;
                        }
                        window.allVariants.push({ type: 'fen', fen: combinedMatch[1], moves: moves, notes: notes, lineIndex: i, gameInfo: currentGameInfo, fileName: currentFileName, fileSectionIndex: currentFileSectionIndex });
                        pendingVariant = false;
                        continue;
                    }

                    // Check for [Variant "From Position"] alone on a line
                    if (line.match(/\[Variant\s+"From\s+Position"\]/)) {
                        // Save any pending PGN first
                        if (currentPgn.trim()) {
                            const notes = getNotesFromLinesBefore(pgnStartLineIndex);
                            window.allVariants.push({ type: 'pgn', pgn: currentPgn.trim(), notes: notes, lineIndex: pgnStartLineIndex, gameInfo: currentGameInfo, fileName: currentFileName, fileSectionIndex: currentFileSectionIndex });
                            currentPgn = '';
                            inPgn = false;
                        }
                        pendingVariant = true;
                        variantLineIndex = i;
                        continue;
                    }

                    // Check for [FEN "..."] after we saw [Variant...]
                    const fenOnlyMatch = line.match(/\[FEN\s+"([^"]+)"\]/);
                    if (fenOnlyMatch && pendingVariant) {
                        const notes = getNotesFromLinesBefore(variantLineIndex);
                        let moves = '';
                        for (let j = i + 1; j < lines.length; j++) {
                            const nextLine = lines[j].trim();
                            if (nextLine.match(/^\d+\./)) {
                                moves = nextLine;
                                break;
                            }
                            if (nextLine.startsWith('[Variant') || nextLine.startsWith('[FEN')) break;
                        }
                        window.allVariants.push({ type: 'fen', fen: fenOnlyMatch[1], moves: moves, notes: notes, lineIndex: variantLineIndex, gameInfo: currentGameInfo, fileName: currentFileName, fileSectionIndex: currentFileSectionIndex });
                        pendingVariant = false;
                        continue;
                    }

                    // Reset pendingVariant if we hit a non-matching line (but not empty lines)
                    if (pendingVariant && line && !line.startsWith('[')) {
                        pendingVariant = false;
                    }

                    // Check for PGN (lines starting with move number like "1. e4")
                    if (/^\d+\.\s*[A-Za-z]/.test(line) && !pendingVariant) {
                        // Skip if this is part of a FEN variant (look back for [FEN])
                        let isFenMoves = false;
                        for (let k = i - 1; k >= Math.max(0, i - 3); k--) {
                            if (lines[k].includes('[FEN')) {
                                isFenMoves = true;
                                break;
                            }
                            if (lines[k].trim() && !lines[k].startsWith('[')) break;
                        }
                        if (isFenMoves) continue;

                        if (!inPgn && currentPgn.trim()) {
                            const notes = getNotesFromLinesBefore(pgnStartLineIndex);
                            window.allVariants.push({ type: 'pgn', pgn: currentPgn.trim(), notes: notes, lineIndex: pgnStartLineIndex, gameInfo: currentGameInfo, fileName: currentFileName, fileSectionIndex: currentFileSectionIndex });
                            currentPgn = '';
                        }
                        if (!inPgn) {
                            pgnStartLineIndex = i;
                        }
                        inPgn = true;
                        currentPgn += line + ' ';
                    } else if (inPgn && /^[A-Za-z0-9]/.test(line) && !line.startsWith('*') && !line.startsWith('[')) {
                        currentPgn += line + ' ';
                    } else if (inPgn && line === '') {
                        if (currentPgn.trim()) {
                            const notes = getNotesFromLinesBefore(pgnStartLineIndex);
                            window.allVariants.push({ type: 'pgn', pgn: currentPgn.trim(), notes: notes, lineIndex: pgnStartLineIndex, gameInfo: currentGameInfo, fileName: currentFileName, fileSectionIndex: currentFileSectionIndex });
                        }
                        currentPgn = '';
                        inPgn = false;
                        pgnStartLineIndex = -1;
                    }
                }
                // Don't forget last PGN
                if (currentPgn.trim()) {
                    const notes = getNotesFromLinesBefore(pgnStartLineIndex);
                    window.allVariants.push({ type: 'pgn', pgn: currentPgn.trim(), notes: notes, lineIndex: pgnStartLineIndex, gameInfo: currentGameInfo, fileName: currentFileName, fileSectionIndex: currentFileSectionIndex });
                }

                // Sort by line index to maintain document order
                window.allVariants.sort((a, b) => a.lineIndex - b.lineIndex);
                window.currentVariantIndex = 0;
                console.log('Total combined variants found:', window.allVariants.length);
                console.log('Total file sections found:', window.allFileSections.length);
                return window.allVariants.length;
            };

            // Update file section header display
            window.updateFileSectionHeader = function(fileSectionIndex) {
                const header = document.getElementById('fileSectionHeader');
                const nameSpan = document.getElementById('fileSectionName');
                const counterSpan = document.getElementById('fileSectionCounter');
                const moveTable = document.getElementById('moveTableContainer');

                if (!header || !nameSpan || !counterSpan) return;

                if (window.allFileSections.length === 0 || fileSectionIndex < 0 || fileSectionIndex === undefined) {
                    header.style.display = 'none';
                    // Restore full border-radius when no header
                    if (moveTable) moveTable.style.borderRadius = '5px';
                    return;
                }

                // Show header
                header.style.display = 'block';
                window.currentFileSectionIndex = fileSectionIndex;
                // Adjust border-radius when header is visible
                if (moveTable) moveTable.style.borderRadius = '0 0 5px 5px';

                const section = window.allFileSections[fileSectionIndex];
                if (section) {
                    nameSpan.textContent = section.displayName;
                    counterSpan.textContent = `(${fileSectionIndex + 1}/${window.allFileSections.length})`;
                }
            };

            // Navigate to file section
            window.navigateToFileSection = function(sectionIndex) {
                if (window.allFileSections.length === 0) return;

                // Wrap around
                if (sectionIndex < 0) sectionIndex = window.allFileSections.length - 1;
                if (sectionIndex >= window.allFileSections.length) sectionIndex = 0;

                const section = window.allFileSections[sectionIndex];
                if (!section) return;

                // Find first variant that belongs to this section
                const firstVariantIndex = window.allVariants.findIndex(v => v.fileSectionIndex === sectionIndex);
                if (firstVariantIndex >= 0) {
                    window.currentVariantIndex = firstVariantIndex;
                    window.loadCurrentVariant();

                    // Scroll report to this section's line
                    const reportText = document.getElementById('analysisReportText');
                    const textarea = document.getElementById('reportEditTextarea');
                    const content = window.isReportEditMode ? textarea.value : (reportText ? reportText.textContent : '');
                    const lines = content.split('\n');

                    // Create a marker for scrolling
                    if (reportText && section.lineIndex < lines.length) {
                        // Highlight the section in the report
                        const lineToScrollTo = section.lineIndex;
                        console.log(`Scrolling to file section: ${section.fileName} at line ${lineToScrollTo}`);
                    }
                }
            };

            // Load current combined variant
            window.loadCurrentVariant = function() {
                if (window.allVariants.length === 0) return;

                const variant = window.allVariants[window.currentVariantIndex];
                let pgnString;

                if (variant.type === 'fen') {
                    pgnString = `[Variant "From Position"]\n[FEN "${variant.fen}"]\n\n${variant.moves}`;
                    window.currentVariantType = 'fen';
                    const result = window.parsePgnToPositionsWithComments(pgnString);
                    window.studyReportPositions = result.positions;
                    window.studyReportComments = result.comments;
                } else {
                    pgnString = variant.pgn;
                    window.currentVariantType = 'pgn';
                    const result = window.parsePgnToPositionsWithComments(variant.pgn);
                    window.studyReportPositions = result.positions;
                    window.studyReportComments = result.comments;
                }

                // Parse with variation support and render move table
                console.log('Parsing PGN with variations:', pgnString.substring(0, 100));
                window.moveTree = window.parsePgnWithVariations(pgnString);
                console.log('Move tree parsed, root children:', window.moveTree?.children?.length);
                if (window.moveTree?.children?.[0]) {
                    console.log('First move:', window.moveTree.children[0].san, 'annotation:', window.moveTree.children[0].annotation);
                }
                window.currentMoveNode = null; // Start at beginning
                renderMoveTable(window.moveTree);
                updateAllCommentsDisplay();

                window.studyReportPositionIndex = 0;
                if (window.studyReportPositions && window.studyReportPositions.length > 0) {
                    window.board2.position(window.studyReportPositions[0]);
                    updateBoard2MoveIndicator(0);
                }

                // Update variant index display
                const indexSpan = document.getElementById('variantIndexDisplay');
                if (indexSpan) {
                    const typeLabel = variant.type === 'fen' ? 'FEN' : 'PGN';
                    indexSpan.textContent = `${typeLabel} ${window.currentVariantIndex + 1}/${window.allVariants.length}`;
                }

                // Update moves span
                const movesSpan = document.getElementById('currentFenMoves');
                if (movesSpan) {
                    const movesText = variant.type === 'fen' ? variant.moves : variant.pgn;
                    const movesDisplay = movesText.length > 7 ? movesText.substring(0, 7) : movesText;
                    movesSpan.textContent = movesDisplay;
                }

                // Update notes display
                const notesSpan = document.getElementById('variantNotesDisplay');
                if (notesSpan) {
                    notesSpan.textContent = variant.notes || '';
                }

                // Update game info display
                const gameInfoSpan = document.getElementById('currentGameInfo');
                if (gameInfoSpan) {
                    let displayText = '';
                    if (variant.fileName) {
                        displayText = `[${variant.fileName}] `;
                    }
                    if (variant.gameInfo) {
                        displayText += variant.gameInfo;
                    }
                    gameInfoSpan.textContent = displayText;
                    gameInfoSpan.title = displayText;
                }

                // Update file section header
                window.updateFileSectionHeader(variant.fileSectionIndex);
            };

            const nextFenVariantBtn = document.getElementById('nextFenVariant');
            if (nextFenVariantBtn) {
                nextFenVariantBtn.addEventListener('click', function() {
                    if (window.fenVariants.length === 0) {
                        const count = window.scanReportForFenVariants();
                        if (count === 0) {
                            alert('No [Variant "From Position"][FEN "..."] blocks found in report.');
                            return;
                        }
                    } else {
                        window.currentFenVariantIndex = (window.currentFenVariantIndex + 1) % window.fenVariants.length;
                    }
                    window.loadCurrentFenVariant();
                });
            }

            // Next PGN Variant Button
            const nextPgnVariantBtn = document.getElementById('nextPgnVariant');
            if (nextPgnVariantBtn) {
                nextPgnVariantBtn.addEventListener('click', function() {
                    if (window.pgnVariants.length === 0) {
                        const count = window.scanReportForPgnVariants();
                        if (count === 0) {
                            alert('No PGN blocks found in report.');
                            return;
                        }
                    } else {
                        window.currentPgnVariantIndex = (window.currentPgnVariantIndex + 1) % window.pgnVariants.length;
                    }
                    window.loadCurrentPgnVariant();
                });
            }

            // Combined Prev FEN/PGN Variant Button
            const prevVariantBtn = document.getElementById('prevVariant');
            if (prevVariantBtn) {
                prevVariantBtn.addEventListener('click', function() {
                    if (window.allVariants.length === 0) {
                        const count = window.scanReportForAllVariants();
                        if (count === 0) {
                            alert('No FEN or PGN variants found in report.');
                            return;
                        }
                    } else {
                        window.currentVariantIndex = (window.currentVariantIndex - 1 + window.allVariants.length) % window.allVariants.length;
                    }
                    window.loadCurrentVariant();
                });
            }

            // Combined Next FEN/PGN Variant Button
            const nextVariantBtn = document.getElementById('nextVariant');
            if (nextVariantBtn) {
                nextVariantBtn.addEventListener('click', function() {
                    if (window.allVariants.length === 0) {
                        const count = window.scanReportForAllVariants();
                        if (count === 0) {
                            alert('No FEN or PGN variants found in report.');
                            return;
                        }
                    } else {
                        window.currentVariantIndex = (window.currentVariantIndex + 1) % window.allVariants.length;
                    }
                    window.loadCurrentVariant();
                });
            }

            // File Section Navigation Buttons
            const fileSectionPrevBtn = document.getElementById('fileSectionPrev');
            if (fileSectionPrevBtn) {
                fileSectionPrevBtn.addEventListener('click', function() {
                    if (window.allFileSections.length === 0) {
                        window.scanReportForAllVariants();
                    }
                    if (window.allFileSections.length > 0) {
                        window.navigateToFileSection(window.currentFileSectionIndex - 1);
                    }
                });
            }

            const fileSectionNextBtn = document.getElementById('fileSectionNext');
            if (fileSectionNextBtn) {
                fileSectionNextBtn.addEventListener('click', function() {
                    if (window.allFileSections.length === 0) {
                        window.scanReportForAllVariants();
                    }
                    if (window.allFileSections.length > 0) {
                        window.navigateToFileSection(window.currentFileSectionIndex + 1);
                    }
                });
            }

            // =========================================================
            // SET VARIANT - Analysis Mode with chess.js
            // =========================================================
            window.board2Chess = null;  // chess.js instance for board2
            window.board2StartingFen = null;  // Starting FEN for variant
            window.board2VariantMode = false;  // Whether we're in variant/analysis mode

            const setVariantBtn = document.getElementById('setVariantBtn');
            if (setVariantBtn) {
                setVariantBtn.addEventListener('click', function() {
                    // Get current position from board2
                    const currentPosition = window.board2.position('fen');

                    // Extract move number and turn from board2MoveIndicator
                    // Format: "12." for white's turn, "12..." for black's turn, "Start" for initial
                    const indicator = document.getElementById('board2MoveIndicator');
                    let moveNumber = 1;
                    let turn = 'w';

                    if (indicator) {
                        const indicatorText = indicator.textContent.trim();
                        if (indicatorText !== 'Start') {
                            // Extract number from "12." or "12..."
                            const match = indicatorText.match(/(\d+)(\.{1,3})/);
                            if (match) {
                                moveNumber = parseInt(match[1]);
                                // "12." = white just moved ‚Üí black's turn
                                // "12..." = black just moved ‚Üí white's turn (move 13)
                                if (match[2] === '.') {
                                    turn = 'b';  // white just moved, black to play
                                } else {
                                    turn = 'w';  // black just moved, white to play
                                    moveNumber++;  // next move number
                                }
                            }
                        }
                    }

                    // Build full FEN with correct turn and move number
                    const fullFen = currentPosition + ' ' + turn + ' KQkq - 0 ' + moveNumber;

                    // Initialize chess.js with this position
                    window.board2Chess = new Chess();
                    const loaded = window.board2Chess.load(fullFen);

                    if (!loaded) {
                        alert('Could not load position into chess.js');
                        return;
                    }

                    window.board2StartingFen = fullFen;
                    window.board2VariantMode = true;

                    // Show the move history textarea
                    const moveHistoryTextArea = document.getElementById('moveHistoryTextArea');
                    if (moveHistoryTextArea) {
                        moveHistoryTextArea.style.display = 'block';
                        moveHistoryTextArea.value = '[Variant "From Position"]\n[FEN "' + fullFen + '"]\n\n';
                    }

                    // Show the Report Append Variant button
                    document.getElementById('reportAppendVariantBtn').style.display = 'inline-block';

                    // Reinitialize board2 with onDrop handler for move tracking
                    window.board2 = Chessboard('myBoard2', {
                        draggable: true,
                        dropOffBoard: 'snapback',
                        position: currentPosition,
                        snapbackSpeed: 500,
                        snapSpeed: 100,
                        pieceTheme: pieceThemePath,

                        onDrop: function(source, target, piece, newPos, oldPos, orientation) {
                            // Attempt move with chess.js
                            const move = window.board2Chess.move({
                                from: source,
                                to: target,
                                promotion: 'q'  // auto-promote to queen
                            });

                            if (move === null) {
                                // Invalid move - snap back
                                return 'snapback';
                            }

                            // Valid move - update PGN display
                            let pgnMoves = window.board2Chess.pgn();
                            // Strip any headers chess.js may have added
                            pgnMoves = pgnMoves.replace(/\[[^\]]*\]\s*/g, '').trim();

                            // Build custom PGN with Variant header
                            const customPgn = '[Variant "From Position"]\n[FEN "' + window.board2StartingFen + '"]\n\n' + pgnMoves;

                            const moveHistoryTextArea = document.getElementById('moveHistoryTextArea');
                            if (moveHistoryTextArea) {
                                moveHistoryTextArea.value = customPgn;
                            }

                            // Copy to clipboard
                            navigator.clipboard.writeText(customPgn).catch(function(err) {
                                console.log('Clipboard write failed:', err);
                            });

                            log(`Move: ${move.san}`, 'info');
                        }
                    });

                    log(`Variant mode enabled. Starting FEN: ${fullFen}`, 'success');
                    log('Make moves on the board - PGN will be generated automatically', 'info');
                });
            }

            // Keyboard Navigation for Board2
            document.addEventListener('keydown', function(e) {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                if (e.key === 'ArrowLeft') {
                    board2PrevMove();
                    e.preventDefault();
                } else if (e.key === 'ArrowRight') {
                    board2NextMove();
                    e.preventDefault();
                }
            });

            // Load Analysis Report from Clipboard
            const loadBtn = document.getElementById('loadAnalysisReport');
            if (loadBtn) {
                loadBtn.addEventListener('click', async function() {
                    try {
                        const clipboardText = await navigator.clipboard.readText();
                        loadStudyReportFromContent(clipboardText, 'clipboard');
                    } catch (err) {
                        console.error('Failed to read clipboard:', err);
                        alert('Could not read clipboard. Please check permissions.');
                    }
                });
            }

            // Report Folder Input Handler
            const reportFolderInput = document.getElementById('reportFolderInput');
            if (reportFolderInput) {
                reportFolderInput.addEventListener('change', async function(e) {
                    const files = Array.from(e.target.files);
                    const txtFiles = files.filter(file => file.name.toLowerCase().endsWith('.txt'));

                    if (txtFiles.length === 0) {
                        log('No .txt files found in selected folder', 'warning');
                        return;
                    }

                    txtFiles.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
                    window.loadedReportFiles = txtFiles;

                    const viewBtn = document.getElementById('viewPreloadedReports');
                    if (viewBtn) {
                        viewBtn.style.display = 'inline-block';
                    }

                    const countDisplay = document.getElementById('reportsCountDisplay');
                    if (countDisplay) {
                        countDisplay.textContent = `${txtFiles.length} Reports Loaded`;
                    }

                    log(`Loaded ${txtFiles.length} report files`, 'success');
                    populateOpeningDropdown();
                    openReportFilesModal();
                });
            }

            // Load Preloaded Reports Button (from JSON files)
            const loadPreloadedBtn = document.getElementById('loadPreloadedReports');
            if (loadPreloadedBtn) {
                loadPreloadedBtn.addEventListener('click', async function() {
                    try {
                        log('Loading preloaded reports...', 'info');

                        // Fetch the reports JSON
                        const response = await fetch('preloaded/reports.json');
                        if (!response.ok) {
                            throw new Error('Could not load preloaded reports. Run generate_preloaded_chess.py first.');
                        }

                        const reportsData = await response.json();
                        const filenames = Object.keys(reportsData);

                        if (filenames.length === 0) {
                            log('No preloaded reports found', 'warning');
                            return;
                        }

                        // Convert to the same format as folder selection
                        // Create file-like objects with name and content
                        window.loadedReportFiles = filenames.map(filename => ({
                            name: filename,
                            content: reportsData[filename],
                            text: function() { return Promise.resolve(this.content); }
                        }));

                        // Sort naturally
                        window.loadedReportFiles.sort((a, b) =>
                            a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' })
                        );

                        // Show the View Reports button
                        const viewBtn = document.getElementById('viewPreloadedReports');
                        if (viewBtn) {
                            viewBtn.style.display = 'inline-block';
                        }

                        // Update count display
                        const countDisplay = document.getElementById('reportsCountDisplay');
                        if (countDisplay) {
                            countDisplay.textContent = `${filenames.length} Reports Loaded`;
                        }

                        log(`Loaded ${filenames.length} preloaded report files`, 'success');
                        populateOpeningDropdown();
                        openReportFilesModal();

                    } catch (err) {
                        console.error('Error loading preloaded reports:', err);
                        log('Failed to load preloaded reports: ' + err.message, 'error');
                        alert('Failed to load preloaded reports. Make sure to run:\npython generate_preloaded_chess.py');
                    }
                });
            }

            // View Reports Button
            const viewReportsBtn = document.getElementById('viewPreloadedReports');
            if (viewReportsBtn) {
                viewReportsBtn.addEventListener('click', openReportFilesModal);
            }

            // Parse filename to extract opening (e.g., "12-07_TTTstanley_white_Italian_Game_.txt")
            function parseReportFilename(filename) {
                // Skip analysis reports
                if (filename.startsWith('chess_analysis')) {
                    return { type: 'report', filename };
                }
                // Pattern: DATE_OPPONENT_COLOR_OPENING.txt
                const match = filename.match(/^(\d+-\d+|\d+_\d+-\d+)_(.+?)_(white|black)_(.+?)\.txt$/i);
                if (match) {
                    return {
                        date: match[1],
                        opponent: match[2],
                        color: match[3],
                        opening: match[4].replace(/_/g, ' ').replace(/,\s*$/, '').trim(),
                        filename
                    };
                }
                return { type: 'unknown', filename };
            }

            // Populate opening dropdown from loaded report files
            function populateOpeningDropdown() {
                const dropdown = document.getElementById('openingDropdown');
                const appendBtn = document.getElementById('appendByOpeningBtn');
                if (!dropdown || !window.loadedReportFiles || window.loadedReportFiles.length === 0) return;

                // Group files by opening
                const openingGroups = {};
                window.loadedReportFiles.forEach(file => {
                    const parsed = parseReportFilename(file.name);
                    if (parsed.opening) {
                        if (!openingGroups[parsed.opening]) {
                            openingGroups[parsed.opening] = [];
                        }
                        openingGroups[parsed.opening].push(file);
                    }
                });

                // Clear and populate dropdown
                dropdown.innerHTML = '<option value="">-- Select Opening --</option>';
                const sortedOpenings = Object.keys(openingGroups).sort();
                sortedOpenings.forEach(opening => {
                    const count = openingGroups[opening].length;
                    const option = document.createElement('option');
                    option.value = opening;
                    option.textContent = `${opening} (${count} game${count > 1 ? 's' : ''})`;
                    dropdown.appendChild(option);
                });

                // Store groups for later use
                window.reportsByOpening = openingGroups;

                // Show dropdown and button if we have openings
                if (sortedOpenings.length > 0) {
                    dropdown.style.display = 'inline-block';
                    appendBtn.style.display = 'inline-block';
                }
            }

            // Append By Opening Button Handler
            const appendByOpeningBtn = document.getElementById('appendByOpeningBtn');
            if (appendByOpeningBtn) {
                appendByOpeningBtn.addEventListener('click', async function() {
                    const dropdown = document.getElementById('openingDropdown');
                    const selectedOpening = dropdown.value;

                    if (!selectedOpening || !window.reportsByOpening || !window.reportsByOpening[selectedOpening]) {
                        alert('Please select an opening first.');
                        return;
                    }

                    const files = window.reportsByOpening[selectedOpening];
                    const reportContainer = document.getElementById('analysisReportContainer');
                    const reportText = document.getElementById('analysisReportText');

                    if (!reportContainer || !reportText) return;

                    reportContainer.style.display = 'block';

                    // Append each report
                    let appendedContent = '';
                    for (const file of files) {
                        try {
                            let content;
                            if (typeof file.text === 'function') {
                                content = await file.text();
                            } else if (file.content) {
                                content = file.content;
                            }

                            if (content) {
                                appendedContent += '\n\n' + '='.repeat(70) + '\n';
                                appendedContent += `FILE: ${file.name}\n`;
                                appendedContent += '='.repeat(70) + '\n';
                                appendedContent += content;
                            }
                        } catch (err) {
                            console.error('Error loading file:', file.name, err);
                        }
                    }

                    if (appendedContent) {
                        // Append to existing content or set new
                        if (reportText.textContent && reportText.textContent.trim() !== '') {
                            reportText.textContent += appendedContent;
                        } else {
                            reportText.textContent = appendedContent.trim();
                        }

                        // Also update textarea if in edit mode
                        const textarea = document.getElementById('reportEditTextarea');
                        if (window.isReportEditMode && textarea) {
                            textarea.value += appendedContent;
                        }

                        // Rescan variants
                        window.fenVariants = [];
                        window.pgnVariants = [];
                        window.allVariants = [];
                        window.scanReportForFenVariants();
                        window.scanReportForPgnVariants();

                        log(`Appended ${files.length} ${selectedOpening} reports`, 'success');
                    }
                });
            }

            // Close Modal Buttons
            const closeModalBtn = document.getElementById('closeReportFilesModal');
            if (closeModalBtn) {
                closeModalBtn.addEventListener('click', function() {
                    document.getElementById('reportFilesModal').style.display = 'none';
                });
            }

            const modal = document.getElementById('reportFilesModal');
            if (modal) {
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        modal.style.display = 'none';
                    }
                });
            }

            // Edit/View Toggle for Report
            window.isReportEditMode = false;
            const editViewToggleBtn = document.getElementById('editViewToggleBtn');
            if (editViewToggleBtn) {
                editViewToggleBtn.addEventListener('click', function() {
                    const reportDiv = document.getElementById('analysisReportText');
                    const textarea = document.getElementById('reportEditTextarea');
                    const toggleBtn = this;

                    if (!window.isReportEditMode) {
                        // Switch to Edit mode
                        textarea.value = reportDiv.textContent;
                        reportDiv.style.display = 'none';
                        textarea.style.display = 'block';
                        toggleBtn.textContent = 'View only';
                        toggleBtn.style.background = '#6a1b9a';
                        window.isReportEditMode = true;
                        textarea.focus();
                    } else {
                        // Switch to View only mode - apply edits
                        reportDiv.textContent = textarea.value;
                        window.analysisReportRawText = textarea.value;
                        textarea.style.display = 'none';
                        reportDiv.style.display = 'block';
                        toggleBtn.textContent = 'Edit';
                        toggleBtn.style.background = '#9c27b0';
                        window.isReportEditMode = false;
                        // Rescan FEN/PGN variants with updated content
                        window.fenVariants = [];
                        window.pgnVariants = [];
                        window.allVariants = [];
                        window.scanReportForFenVariants();
                        window.scanReportForPgnVariants();
                        document.getElementById('currentFenMoves').textContent = '';
                        document.getElementById('variantIndexDisplay').textContent = '';
                    }
                });
            }

            // Report Append Variant Button
            const reportAppendVariantBtn = document.getElementById('reportAppendVariantBtn');
            if (reportAppendVariantBtn) {
                reportAppendVariantBtn.addEventListener('click', function() {
                    const moveHistoryTextArea = document.getElementById('moveHistoryTextArea');
                    const variantText = moveHistoryTextArea.value.trim();

                    if (!variantText) {
                        alert('No variant to append. Use "Set Variant" first.');
                        return;
                    }

                    const reportDiv = document.getElementById('analysisReportText');
                    const textarea = document.getElementById('reportEditTextarea');

                    if (window.isReportEditMode) {
                        // Append to textarea in edit mode
                        textarea.value += '\n\n' + variantText;
                    } else {
                        // Append to view mode content
                        reportDiv.textContent += '\n\n' + variantText;
                        window.analysisReportRawText = reportDiv.textContent;
                    }

                    // Clear moveHistoryTextArea and hide this button
                    moveHistoryTextArea.value = '';
                    moveHistoryTextArea.style.display = 'none';
                    this.style.display = 'none';

                    // Rescan variants to include newly appended one
                    window.scanReportForFenVariants();
                    window.scanReportForPgnVariants();
                });
            }

            // Save Report Button
            const saveReportBtn = document.getElementById('saveReportBtn');
            if (saveReportBtn) {
                saveReportBtn.addEventListener('click', function() {
                    const reportText = document.getElementById('analysisReportText');
                    const reportTextarea = document.getElementById('reportEditTextarea');
                    // Get content based on current mode
                    const content = window.isReportEditMode ? reportTextarea.value : reportText.textContent;
                    if (content && content.trim() && content !== 'Loading report...') {
                        const blob = new Blob([content], { type: 'text/plain' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;

                        // Use filename from display span if available, otherwise generate
                        const filenameDisplay = document.getElementById('reportFilenameDisplay');
                        let filename = 'chess_report.txt';
                        if (filenameDisplay && filenameDisplay.textContent) {
                            // Remove the üìÅ prefix and trim
                            filename = filenameDisplay.textContent.replace(/^üìÅ\s*/, '').trim();
                            if (!filename.endsWith('.txt')) filename += '.txt';
                        }
                        if (!filename || filename === '.txt') {
                            filename = generateReportFilename();
                        }
                        a.download = filename;
                        a.style.display = 'none';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    } else {
                        alert('No report content to save.');
                    }
                });
            }

            // Save Socratic Method Button
            const saveSocraticBtn = document.getElementById('saveSocraticBtn');
            if (saveSocraticBtn) {
                saveSocraticBtn.addEventListener('click', function() {
                    const socraticContent = `================================================================================

SOCRATIC COACHING: A GUIDE TO TEACHING THROUGH QUESTIONS
================================================================================

The Socratic method, named after the Greek philosopher Socrates, is a form of
cooperative dialogue where learning happens through asking and answering
questions. Instead of lecturing or giving direct answers, the coach guides
the learner to discover insights on their own.

================================================================================

### PART 1: CORE PRINCIPLES OF SOCRATIC COACHING

1. ASK, DON'T TELL

-------------------

Instead of: "Your move was bad because it loses a tempo."
Ask: "What do you think your opponent can do now that they couldn't before?"

The learner remembers insights they discover far better than facts they're told.


2. VALIDATE FIRST, THEN PROBE

-----------------------------

Always find something reasonable in the learner's thinking before challenging it.

Instead of: "That's wrong. You should have played Nf6."
Say: "I see you were trying to prevent the pin - that's good defensive thinking!
      But let me ask: if the pin does happen, how dangerous is it really?"

This keeps the learner open and engaged rather than defensive.


3. GUIDE TO PRINCIPLES, NOT JUST MOVES

--------------------------------------

Connect specific situations to broader understanding.

Instead of: "Nf6 is better here."
Ask: "In the opening, we want to develop pieces quickly. How many pieces have
      you developed vs your opponent? What does that tell you about a6 vs Nf6?"

This builds transferable knowledge they can apply to new situations.


4. ONE QUESTION AT A TIME

-------------------------

Don't overwhelm with multiple questions. Ask one, wait for reflection, then
build on their response.


5. END WITH ACTION

------------------

Give one concrete thing to study or practice. Not a list of five things.

"Try this: Set up the position after Nf6 Bb5. Find three natural developing
moves that also handle the pin. You'll see why masters aren't worried."


================================================================================

PART 2: THE COACHING CONVERSATION FLOW
================================================================================

Step 1: UNDERSTAND THEIR THINKING
---------------------------------

Before correcting, understand why they made the choice.

Questions to ask:

- "What were you trying to accomplish with this move?"
- "What threats were you seeing?"
- "What was your plan for the next few moves?"


Step 2: REVEAL THE GAP
----------------------

Help them see what they missed through questions, not statements.

Questions to ask:

- "What can your opponent do now?"
- "How does this compare to the alternative?"
- "What principle might apply here?"


Step 3: TEACH THE PRINCIPLE
---------------------------

Connect to a broader concept they can remember and reuse.

Examples of principles:

- "Development over prevention in the opening"
- "Activity matters more than material in some positions"
- "When ahead, trade pieces; when behind, trade pawns"


Step 4: GIVE CONCRETE PRACTICE
------------------------------

One specific exercise or study task.

Examples:

- "Play through 5 master games in this opening"
- "Set up this position and find 3 good moves for Black"
- "Practice this puzzle theme on Lichess"


================================================================================

PART 3: CODE EXAMPLES FROM chess_coach.py
================================================================================

EXAMPLE 1: Building the System Prompt
-------------------------------------

This is how we instruct Claude to behave as a Socratic coach:

\`\`\`python
def build_coaching_system_prompt(context_type: str, context_data: dict) -> str:
    """Build the system prompt for Claude coaching"""

    base_prompt = """You are a thoughtful chess coach using the Socratic method.
Your role is to guide players to discover insights rather than lecturing them.

COACHING PRINCIPLES:
1. Start with validation - find what's reasonable in their thinking
2. Ask probing questions - help them discover what they missed
3. Teach principles - connect to broader chess understanding
4. Give concrete actions - one specific thing to study or practice

TONE: Encouraging, curious, thought-provoking. Like a wise mentor, not a critic.

IMPORTANT:
- Don't just cite engine evaluations
- Help build intuition and pattern recognition
- Keep responses focused and under 200 words
- End with a thought-provoking question or concrete study suggestion
"""

    if context_type == "deviation":
        dev = context_data
        return base_prompt + f"""

CURRENT CONTEXT - OPENING DEVIATION:
- Move played: {dev['move_played']}
- Main theory: {dev['main_line']} ({dev['percentage']}% of master games)
- Alternatives: {dev['alternatives']}
- Opening: {dev['opening_name']}
- Position (FEN): {dev['fen']}

Focus on helping them understand opening principles and why theory developed
this way."""

    elif context_type == "error":
        err = context_data
        return base_prompt + f"""

CURRENT CONTEXT - {err['severity']}:
- Move played: {err['notation']} {err['move']}
- Evaluation change: {err['eval_before']:.2f} -> {err['eval_after']:.2f}
- Position (FEN): {err['fen']}

Focus on helping them understand what they missed and how to spot similar
patterns."""

    return base_prompt
\`\`\`

KEY POINTS IN THIS CODE:

- The system prompt explicitly tells Claude to use Socratic method
- It lists the 4 coaching principles (validate, probe, teach, action)
- It sets the tone (encouraging, curious, not critical)
- It provides context about the specific position being discussed
- It ends with guidance on what to focus on


EXAMPLE 2: Pre-defined Reflective Prompts
-----------------------------------------

These prompts model the kind of questions a Socratic coach would ask:

\`\`\`python
def get_deviation_prompts(deviation: OpeningDeviation) -> List[Dict[str, str]]:
    """Get pre-defined prompts for opening deviations"""
    move = deviation.move_played
    main = deviation.main_line_move
    opening = deviation.opening_name if deviation.opening_name else "this opening"

    return [
        {
            "label": "Why did I play this?",
            "prompt": f"In the {opening}, I played {move} instead of the main
                       line {main}. What were you trying to accomplish with {move}?"
        },
        {
            "label": "What's the main line idea?",
            "prompt": f"In the {opening}, what is {main} trying to achieve?
                       Why do masters prefer it over {move}?"
        },
        {
            "label": "Is my move bad?",
            "prompt": f"In the {opening}, I played {move} instead of {main}.
                       Is my move actually bad, or just a sideline?
                       What are the consequences?"
        },
        {
            "label": "What should I study?",
            "prompt": f"After deviating from the {opening} with {move} instead
                       of {main}, what should I study to understand this
                       opening better?"
        }
    ]
\`\`\`

KEY POINTS IN THIS CODE:

- Each prompt is a QUESTION, not a statement
- They ask about the learner's thinking ("What were you trying to accomplish?")
- They ask about understanding ("What is X trying to achieve?")
- They invite exploration ("Is my move actually bad, or just different?")
- They end with actionable learning ("What should I study?")


EXAMPLE 3: Error Analysis Prompts
---------------------------------

Different types of mistakes call for different questions:

\`\`\`python
def get_error_prompts(error: MoveError) -> List[Dict[str, str]]:
    """Get pre-defined prompts for move errors"""
    move = error.move
    severity = error.severity.lower()

    return [
        {
            "label": "What went wrong?",
            "prompt": f"My move {error.notation} {move} was a {severity}.
                       What did I miss? What should I have considered?"
        },
        {
            "label": "What was better?",
            "prompt": f"Instead of {move}, what would have been better?
                       Help me understand the key difference."
        },
        {
            "label": "Why is this losing?",
            "prompt": f"The evaluation dropped significantly after {move}.
                       Can you explain concretely what makes this position worse?"
        },
        {
            "label": "Pattern to remember",
            "prompt": f"After this {severity} ({move}), what pattern or principle
                       should I remember to avoid similar mistakes?"
        }
    ]
\`\`\`

KEY POINTS IN THIS CODE:

- "What did I miss?" - encourages self-reflection
- "Help me understand" - positions AI as guide, not judge
- "Can you explain concretely" - asks for specific, actionable insight
- "What pattern should I remember" - focuses on transferable learning


================================================================================

PART 4: PROMPT TEMPLATES FOR DIFFERENT SITUATIONS
================================================================================

TEMPLATE 1: Premature Pawn Move
-------------------------------

When the learner pushes a pawn instead of developing a piece:

"I notice you played [pawn move] instead of developing a piece like [Nf6/Nc6].

Let me ask:

- How many pieces have you developed so far?
- What does [pawn move] threaten or accomplish?
- What could [developing move] have done for your position?

The principle here is that each opening move is precious. Pawn moves often
don't create immediate threats, while piece development does.

Try this: Count your developed pieces vs your opponent's after move 5.
What does that tell you?"


TEMPLATE 2: Moving Same Piece Twice
-----------------------------------

When the learner moves a piece that already moved:

"You moved your [piece] for the second time while your [other pieces] are
still on their starting squares.

Questions to consider:

- How many of your pieces are actively placed right now?
- What was so urgent that you needed to move [piece] again?
- Could a different piece have accomplished something similar?

The principle: 'Touch each piece once' in the opening. Every time you move
the same piece twice, your opponent develops two pieces to your one.

Exercise: Replay this opening and try to develop a NEW piece each move.
How does the position feel different?"


TEMPLATE 3: Tactical Oversight (Blunder)
----------------------------------------

When the learner misses a tactic:

"After [move], the evaluation changed significantly. Let's explore why.

Before I tell you what you missed, let me ask:

- What was your plan when you played [move]?
- Did you check what your opponent could do in response?
- Were there any pieces that felt 'loose' or undefended?

[After they respond]

The pattern here is [fork/pin/discovered attack/etc.]. These often happen when
pieces are uncoordinated or squares are left undefended.

Practice suggestion: Do 10 puzzles on Lichess with the '[theme]' tag.
You'll start seeing these patterns before they happen."


TEMPLATE 4: Positional Mistake
------------------------------

When the learner makes a strategic error:

"Your move [move] wasn't a tactical blunder, but it gave your opponent
something they didn't have before.

Think about:

- What squares did you weaken?
- What outposts did you give your opponent?
- How did this affect your piece coordination?

Compare to [better move]: where would your pieces be headed? What would your
plan be?

The principle: Every pawn move creates permanent weaknesses. Before pushing
a pawn, ask 'what square am I giving up?'

Study suggestion: Look up games in this structure and see how masters handle
the pawn tension differently."


================================================================================

PART 5: HOW TO PRACTICE SOCRATIC PROMPTING
================================================================================

EXERCISE 1: Transform Statements into Questions
-----------------------------------------------

Take any direct statement and convert it to a question.

Statement: "You should have castled earlier."
Question: "What was preventing you from castling? What might have happened
          if you had castled on move 8 instead?"

Statement: "That move loses a pawn."
Question: "After your move, what can your opponent capture? Is anything
          left undefended?"

Practice: Take 5 chess tips you know and rewrite them as questions.


EXERCISE 2: The 5 Whys
----------------------

When someone makes a mistake, ask "why" 5 times to get to the root cause.

1. Why did you play a6? "To prevent Bb5"
2. Why were you worried about Bb5? "It pins my knight"
3. Why is the pin dangerous? "I can't move my knight"
4. Why can't you just break the pin? "Oh... I could play Be7 or castle"
5. Why didn't you consider that? "I didn't look at defensive resources"

Root insight: The learner needs to practice looking for defensive resources
before spending a tempo on prevention.


EXERCISE 3: Validate-Probe-Teach Practice
-----------------------------------------

For any mistake, write out:

1. VALIDATE: What's reasonable about their thinking?
   "You were right to think about the pin on f6..."

2. PROBE: What question reveals the gap?
   "But what happens after Bb5 Be7? Is the pin still a problem?"

3. TEACH: What principle connects?
   "Development often solves tactical problems naturally."

Practice: Do this for 3 mistakes per day. It becomes automatic.


EXERCISE 4: Study Real Coaches
------------------------------

Watch how great teachers ask questions:

Chess:

- Daniel Naroditsky's "Speedrun" series (explains thought process)
- Levy Rozman's guess-the-move videos
- Hikaru's analysis with viewers

General Teaching:

- Read "A More Beautiful Question" by Warren Berger
- Study how therapists use questions (motivational interviewing)
- Watch masterclass teachers in any field


EXERCISE 5: Prompt Engineering Practice
---------------------------------------

Write prompts that force Socratic responses:

Weak prompt: "Tell me why Nf6 is better than a6"
Strong prompt: "Help me understand the difference between Nf6 and a6 by
               asking me questions about what each move accomplishes"

Weak prompt: "What's wrong with my move?"
Strong prompt: "Guide me to discover what I missed by asking about what
               my opponent can do now"

Practice: Before sending any prompt, ask "Am I asking for answers or
asking for guidance?"


================================================================================

PART 6: MEASURING COACHING EFFECTIVENESS
================================================================================

Signs your Socratic approach is working:

1. LEARNER ASKS FOLLOW-UP QUESTIONS
   They're engaged and curious, not just receiving information.

2. LEARNER SAYS "OH, I SEE"
   They're having genuine insights, not just hearing facts.

3. LEARNER APPLIES LESSONS LATER
   They reference previous coaching in new situations.

4. LEARNER STARTS ASKING THEMSELVES QUESTIONS
   "Wait, what can my opponent do here?" becomes automatic.

5. MISTAKES CHANGE CHARACTER
   They stop making the same type of mistake repeatedly.


Signs to adjust your approach:

1. LEARNER SEEMS FRUSTRATED
   You might be asking too many questions without enough guidance.
   Balance: Sometimes give a direct hint, then ask a follow-up.

2. LEARNER GIVES SURFACE ANSWERS
   Your questions might be too vague.
   Fix: Make questions more specific and concrete.

3. LEARNER WAITS FOR ANSWERS
   They've learned you'll eventually tell them.
   Fix: Stay patient. Silence is okay. Rephrase the question.


================================================================================

PART 7: ADAPTING FOR DIFFERENT SKILL LEVELS
================================================================================

BEGINNERS (< 1200 rating)
-------------------------

- More validation, less probing
- Simpler questions with clearer answers
- Focus on basic principles (development, king safety, material)
- Give more concrete guidance
- Shorter coaching exchanges

Example: "Great that you're thinking about defense! Quick question:
which piece hasn't moved yet? What might it do for your position?"


INTERMEDIATE (1200-1800)
------------------------

- Balance of validation and challenge
- Questions about calculation and evaluation
- Focus on pattern recognition
- Encourage concrete variations
- Medium-length exchanges

Example: "You saw the pin threat - that's good awareness. But before
preventing it, did you calculate what happens if you let it occur?
Play out Nf6 Bb5 in your head - then what?"


ADVANCED (1800+)
----------------

- More challenging questions
- Questions about nuance and alternatives
- Focus on deep strategic understanding
- Expect detailed analysis in responses
- Longer, more complex exchanges

Example: "Interesting choice to prevent Bb5. In the master database,
a6 scores slightly worse than Nf6 here. What structural or dynamic
factors might explain that statistical difference?"


================================================================================

SUMMARY: THE SOCRATIC COACHING CHECKLIST
================================================================================

Before coaching, ask yourself:

[ ] Am I asking or telling?
[ ] Have I found something to validate?
[ ] Is my question specific and concrete?
[ ] Does this connect to a broader principle?
[ ] Am I ending with one actionable step?
[ ] Is my tone encouraging, not critical?
[ ] Am I at the right level for this learner?

The goal is not to show how much you know.
The goal is to help them discover what they can learn.

================================================================================

END OF GUIDE
================================================================================

"I cannot teach anybody anything. I can only make them think."

- Socrates

================================================================================`;

                    const blob = new Blob([socraticContent], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'Socratic_Coaching_Guide.txt';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    log('Socratic Method guide saved', 'success');
                });
            }

            // Load Mistakes Button
            const loadMistakesBtn = document.getElementById('loadMistakesBtn');
            if (loadMistakesBtn) {
                loadMistakesBtn.addEventListener('click', function() {
                    const reportText = document.getElementById('analysisReportText');
                    if (!reportText || !reportText.textContent || reportText.textContent === 'Loading report...') {
                        alert('No report loaded. Please analyze a game or load a report first.');
                        return;
                    }

                    const content = reportText.textContent;

                    // Parse mistakes from the report
                    // Format: MISTAKE: 12... O-O-O, Eval: ..., BLUNDER: 17. d4, Eval: ..., INACCURACY: 5. Nf3, Eval: ...
                    window.loadedMistakes = {};

                    // Match patterns like "MISTAKE: 12... O-O-O", "BLUNDER: 17. d4", or "INACCURACY: 5. Nf3"
                    const mistakeRegex = /(MISTAKE|BLUNDER|INACCURACY):\s*(\d+)(\.{1,3})\s*[A-Za-z0-9+#=-]+/g;
                    let match;

                    while ((match = mistakeRegex.exec(content)) !== null) {
                        const severity = match[1]; // MISTAKE, BLUNDER, or INACCURACY
                        const moveNum = match[2];  // 12, 13, 17, etc.
                        const dots = match[3];     // . or ...

                        const notation = `${moveNum}${dots}`;
                        window.loadedMistakes[notation] = severity;
                    }

                    const mistakeCount = Object.values(window.loadedMistakes).filter(s => s === 'MISTAKE').length;
                    const blunderCount = Object.values(window.loadedMistakes).filter(s => s === 'BLUNDER').length;
                    const inaccuracyCount = Object.values(window.loadedMistakes).filter(s => s === 'INACCURACY').length;

                    if (Object.keys(window.loadedMistakes).length > 0) {
                        log(`Loaded ${mistakeCount} mistakes, ${blunderCount} blunders, and ${inaccuracyCount} inaccuracies`, 'success');
                        // Refresh the current indicator to show highlighting
                        updateBoard2MoveIndicator(window.studyReportPositionIndex);

                        // Build list of moves that will be highlighted
                        const mistakeMoves = [];
                        const blunderMoves = [];
                        const inaccuracyMoves = [];
                        for (const [notation, severity] of Object.entries(window.loadedMistakes)) {
                            if (severity === 'MISTAKE') {
                                mistakeMoves.push(notation);
                            } else if (severity === 'BLUNDER') {
                                blunderMoves.push(notation);
                            } else if (severity === 'INACCURACY') {
                                inaccuracyMoves.push(notation);
                            }
                        }

                        let message = `Move #s will be highlighted:\n\n`;
                        if (blunderMoves.length > 0) {
                            message += `BLUNDERS (red): ${blunderMoves.join(', ')}\n`;
                        }
                        if (mistakeMoves.length > 0) {
                            message += `MISTAKES (orange): ${mistakeMoves.join(', ')}\n`;
                        }
                        if (inaccuracyMoves.length > 0) {
                            message += `INACCURACIES (green): ${inaccuracyMoves.join(', ')}`;
                        }

                        alert(message);
                    } else {
                        alert('No mistakes, blunders, or inaccuracies found in the report.');
                    }
                });
            }

            // Remove Mistakes Button
            const removeMistakesBtn = document.getElementById('removeMistakesBtn');
            if (removeMistakesBtn) {
                removeMistakesBtn.addEventListener('click', function() {
                    const mistakeCount = Object.keys(window.loadedMistakes).length;
                    if (mistakeCount === 0) {
                        alert('No mistakes are currently loaded.');
                        return;
                    }

                    window.loadedMistakes = {};
                    // Refresh the indicator to remove highlighting
                    updateBoard2MoveIndicator(window.studyReportPositionIndex);
                    log('Mistakes cleared - highlighting removed', 'info');
                    alert('Mistakes removed. Highlighting has been cleared.');
                });
            }

            // Vercel Blob Storage Configuration
            const VERCEL_API_BASE = 'https://react-quick-docs.vercel.app';
            const VERCEL_FILENAME = 'chess.txt';

            // Helper function to get stored access code
            function getVercelAccessCode() {
                return localStorage.getItem('vercelAccessCode') || '';
            }

            // Helper function to store access code
            function setVercelAccessCode(code) {
                localStorage.setItem('vercelAccessCode', code);
            }

            // Load from Vercel Button
            const loadFromVercelBtn = document.getElementById('loadFromVercelBtn');
            if (loadFromVercelBtn) {
                loadFromVercelBtn.addEventListener('click', async function() {
                    try {
                        log('Fetching chess.txt from Vercel...', 'info');

                        const response = await fetch(`${VERCEL_API_BASE}/api/files`);
                        const responseText = await response.text();

                        // Check if response is HTML (error page) instead of JSON
                        if (responseText.trim().startsWith('<!') || responseText.trim().startsWith('<html')) {
                            throw new Error('API endpoint not found. Make sure react-chat-report-viewer is deployed with /api/files endpoint.');
                        }

                        let data;
                        try {
                            data = JSON.parse(responseText);
                        } catch (parseError) {
                            throw new Error(`Invalid JSON response: ${responseText.substring(0, 100)}...`);
                        }

                        if (!response.ok) {
                            throw new Error(data.error || `HTTP ${response.status}: ${response.statusText}`);
                        }

                        // Extract chess.txt from the files object
                        const content = data.files && data.files[VERCEL_FILENAME];

                        if (content) {
                            // Load content into the report text area
                            const reportContainer = document.getElementById('analysisReportContainer');
                            const reportText = document.getElementById('analysisReportText');

                            if (reportContainer && reportText) {
                                reportContainer.style.display = 'block';
                                reportText.textContent = content;
                                window.studyReportRawText = content;

                                // Update filename display
                                const filenameDisplay = document.getElementById('reportFilenameDisplay');
                                if (filenameDisplay) {
                                    filenameDisplay.textContent = 'üìÅ ' + VERCEL_FILENAME + ' (from Vercel)';
                                }

                                log(`Loaded ${VERCEL_FILENAME} from Vercel (${content.length} characters)`, 'success');
                                alert(`Successfully loaded ${VERCEL_FILENAME} from Vercel!`);
                            }
                        } else {
                            alert(`File ${VERCEL_FILENAME} does not exist on Vercel yet. Save some content first.`);
                            log(`File ${VERCEL_FILENAME} not found on Vercel`, 'warning');
                        }
                    } catch (error) {
                        console.error('Error loading from Vercel:', error);
                        log('Error loading from Vercel: ' + error.message, 'error');
                        alert('Error loading from Vercel: ' + error.message);
                    }
                });
            }

            // Save to Vercel Button
            const saveToVercelBtn = document.getElementById('saveToVercelBtn');
            if (saveToVercelBtn) {
                saveToVercelBtn.addEventListener('click', async function() {
                    const reportText = document.getElementById('analysisReportText');

                    if (!reportText || !reportText.textContent || reportText.textContent === 'Loading report...') {
                        alert('No report content to save. Please analyze a game or load a report first.');
                        return;
                    }

                    const content = reportText.textContent;

                    // Ask for access code
                    let accessCode = getVercelAccessCode();
                    const inputCode = prompt('Enter ACCESS_CODE for Vercel:', accessCode);

                    if (inputCode === null) {
                        // User cancelled
                        return;
                    }

                    accessCode = inputCode.trim();
                    if (!accessCode) {
                        alert('Access code is required.');
                        return;
                    }

                    setVercelAccessCode(accessCode);

                    try {
                        log('Saving to Vercel...', 'info');

                        const response = await fetch(`${VERCEL_API_BASE}/api/files`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                filename: VERCEL_FILENAME,
                                content: content,
                                accessCode: accessCode
                            })
                        });

                        const responseText = await response.text();

                        // Check if response is HTML (error page) instead of JSON
                        if (responseText.trim().startsWith('<!') || responseText.trim().startsWith('<html')) {
                            throw new Error('API endpoint not found. Make sure react-chat-report-viewer is deployed with /api/files endpoint.');
                        }

                        let data;
                        try {
                            data = JSON.parse(responseText);
                        } catch (parseError) {
                            throw new Error(`Invalid JSON response: ${responseText.substring(0, 100)}...`);
                        }

                        if (!response.ok) {
                            throw new Error(data.error || `HTTP ${response.status}: ${response.statusText}`);
                        }

                        log(`Saved ${VERCEL_FILENAME} to Vercel (${content.length} characters)`, 'success');
                        alert(`Successfully saved to ${VERCEL_FILENAME} on Vercel!`);

                        // Update filename display
                        const filenameDisplay = document.getElementById('reportFilenameDisplay');
                        if (filenameDisplay) {
                            filenameDisplay.textContent = 'üìÅ ' + VERCEL_FILENAME + ' (saved to Vercel)';
                        }
                    } catch (error) {
                        console.error('Error saving to Vercel:', error);
                        log('Error saving to Vercel: ' + error.message, 'error');
                        alert('Error saving to Vercel: ' + error.message);
                    }
                });
            }

            // Load PGN from Highlight Button
            const loadPgnFromHighlightBtn = document.getElementById('loadPgnFromHighlight');
            if (loadPgnFromHighlightBtn) {
                loadPgnFromHighlightBtn.addEventListener('click', function() {
                    const selection = window.getSelection();
                    const selectedText = selection.toString().trim();

                    if (!selectedText || selectedText === '') {
                        alert('No text is highlighted. Please highlight/select a PGN first.');
                        return;
                    }

                    let pgnText = selectedText;
                    pgnText = pgnText.split('\n')
                        .filter(line => !line.trim().startsWith('['))
                        .join(' ')
                        .replace(/\s+/g, ' ')
                        .trim();

                    if (!/\d+\./.test(pgnText)) {
                        alert('Selected text does not contain valid PGN.');
                        return;
                    }

                    if (typeof window.parsePgnToPositions === 'function') {
                        window.studyReportPositions = window.parsePgnToPositions(pgnText);
                        window.studyReportPositionIndex = 0;

                        if (window.studyReportPositions && window.studyReportPositions.length > 0) {
                            if (window.board2) {
                                window.board2.position(window.studyReportPositions[0]);
                                updateBoard2MoveIndicator(0);
                            }
                            log(`Loaded ${window.studyReportPositions.length} positions from highlighted PGN`, 'success');
                        }
                    } else {
                        alert('PGN parser not available.');
                    }
                });
            }

            // Load [Fen Variant] from Highlight Button
            const loadFenVariantFromHighlightBtn = document.getElementById('loadFenVariantFromHighlight');
            if (loadFenVariantFromHighlightBtn) {
                loadFenVariantFromHighlightBtn.addEventListener('click', function() {
                    const selection = window.getSelection();
                    const selectedText = selection.toString().trim();

                    if (!selectedText || selectedText === '') {
                        alert('No text is highlighted. Please highlight/select text containing [Variant "From Position"][FEN "..."] format.');
                        return;
                    }

                    // Check if it's the Variant FEN format
                    if (!window.isVariantFenContent(selectedText)) {
                        alert('Selected text does not contain valid [Variant "From Position"][FEN "..."] format.\n\nExpected format:\n[Variant "From Position"]\n[FEN "r1bq1rk1/..."]\n\n12. Qd2 Bxa1 13. Nxe7+ ...');
                        return;
                    }

                    if (typeof window.parsePgnToPositions === 'function') {
                        window.studyReportPositions = window.parsePgnToPositions(selectedText);
                        window.studyReportPositionIndex = 0;

                        if (window.studyReportPositions && window.studyReportPositions.length > 0) {
                            if (window.board2) {
                                window.board2.position(window.studyReportPositions[0]);
                                updateBoard2MoveIndicator(0);
                            }
                            log(`Loaded ${window.studyReportPositions.length} positions from Variant FEN format (starting from custom position)`, 'success');
                        } else {
                            alert('Could not parse positions from the selected text.');
                        }
                    } else {
                        alert('PGN parser not available.');
                    }
                });
            }

            // Copy Report Text Button
            const copyReportTextBtn = document.getElementById('copyReportText');
            if (copyReportTextBtn) {
                copyReportTextBtn.addEventListener('click', function() {
                    const reportText = document.getElementById('analysisReportText');
                    const textarea = document.getElementById('reportEditTextarea');
                    const content = window.isReportEditMode ? textarea.value : reportText.textContent;

                    if (!content || content === 'Loading report...' || content.trim() === '') {
                        alert('No report text to copy.');
                        return;
                    }

                    navigator.clipboard.writeText(content).then(function() {
                        const originalText = copyReportTextBtn.textContent;
                        copyReportTextBtn.textContent = 'Copied!';
                        setTimeout(function() {
                            copyReportTextBtn.textContent = originalText;
                        }, 1500);
                    }).catch(function(err) {
                        alert('Failed to copy text: ' + err);
                    });
                });
            }

            // Load Reference Image Button
            const loadRefImageBtn = document.getElementById('loadRefImageBtn');
            if (loadRefImageBtn) {
                loadRefImageBtn.addEventListener('click', function() {
                    if (refImageLoaded) {
                        document.getElementById('refImageModal').style.display = 'block';
                    } else {
                        document.getElementById('refImageFileInput').click();
                    }
                });
            }

            // Reference Image File Input (multiple images)
            const refImageFileInput = document.getElementById('refImageFileInput');
            if (refImageFileInput) {
                refImageFileInput.addEventListener('change', function(e) {
                    const files = Array.from(e.target.files);
                    if (!files.length) return;

                    // Filter to only image files and sort by name (natural numeric sorting)
                    const imageFiles = files
                        .filter(file => file.type.startsWith('image/'))
                        .sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));

                    if (!imageFiles.length) {
                        alert('Please select image files (PNG, JPG, etc.)');
                        return;
                    }

                    // Store all images with their data URLs
                    loadedRefImages = [];
                    currentRefImageIndex = 0;
                    let loadedCount = 0;

                    imageFiles.forEach((file, index) => {
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            loadedRefImages[index] = {
                                name: file.name,
                                url: event.target.result
                            };
                            loadedCount++;

                            // Once all images are loaded, display the first one
                            if (loadedCount === imageFiles.length) {
                                // Show/hide nav buttons based on count
                                const showNav = loadedRefImages.length > 1;
                                document.getElementById('refImagePrevBtn').style.display = showNav ? 'block' : 'none';
                                document.getElementById('refImageNextBtn').style.display = showNav ? 'block' : 'none';

                                // Update button text
                                document.getElementById('loadRefImageBtn').textContent = 'üñºÔ∏è ' + loadedRefImages.length + ' images loaded';

                                // Hide placeholder, show image
                                document.getElementById('refImagePlaceholder').style.display = 'none';
                                document.getElementById('refImagePreview').style.display = 'block';

                                refImageLoaded = true;
                                refImageIsEnlarged = false;

                                // Display first image
                                updateRefImageDisplay();

                                // Show the modal
                                document.getElementById('refImageModal').style.display = 'block';
                            }
                        };
                        reader.readAsDataURL(file);
                    });
                });
            }

            // Update displayed reference image
            function updateRefImageDisplay() {
                if (!loadedRefImages.length) return;

                const item = loadedRefImages[currentRefImageIndex];
                document.getElementById('refImagePreview').src = item.url;
                document.getElementById('refImageTitle').textContent = item.name;
                document.getElementById('refImageCounter').textContent = (currentRefImageIndex + 1) + ' / ' + loadedRefImages.length;
            }

            // Navigate between reference images
            function navigateRefImage(direction) {
                if (!loadedRefImages.length) return;

                currentRefImageIndex += direction;

                // Wrap around
                if (currentRefImageIndex < 0) {
                    currentRefImageIndex = loadedRefImages.length - 1;
                } else if (currentRefImageIndex >= loadedRefImages.length) {
                    currentRefImageIndex = 0;
                }

                updateRefImageDisplay();
            }

            // Nav button event listeners
            const refImagePrevBtn = document.getElementById('refImagePrevBtn');
            if (refImagePrevBtn) {
                refImagePrevBtn.addEventListener('click', function() {
                    navigateRefImage(-1);
                });
            }

            const refImageNextBtn = document.getElementById('refImageNextBtn');
            if (refImageNextBtn) {
                refImageNextBtn.addEventListener('click', function() {
                    navigateRefImage(1);
                });
            }

            // Close Reference Image Modal
            const closeRefImageModalBtn = document.getElementById('closeRefImageModal');
            if (closeRefImageModalBtn) {
                closeRefImageModalBtn.addEventListener('click', function() {
                    document.getElementById('refImageModal').style.display = 'none';
                });
            }

            const refImageModal = document.getElementById('refImageModal');
            if (refImageModal) {
                refImageModal.addEventListener('click', function(e) {
                    if (e.target === refImageModal) {
                        refImageModal.style.display = 'none';
                    }
                });
            }

            // Reference Image Zoom Toggle
            const refImagePreview = document.getElementById('refImagePreview');
            if (refImagePreview) {
                refImagePreview.addEventListener('click', function() {
                    if (refImageIsEnlarged) {
                        this.style.maxWidth = '100%';
                        this.style.maxHeight = '70vh';
                        this.style.cursor = 'zoom-in';
                        refImageIsEnlarged = false;
                    } else {
                        this.style.maxWidth = 'none';
                        this.style.maxHeight = 'none';
                        this.style.cursor = 'zoom-out';
                        refImageIsEnlarged = true;
                    }
                });
            }

            log('Study tool initialized', 'success');
        };
    </script>

    <!-- React CDN for Chess Coach Chat -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- Chess Coach Chat Container -->
    <div class="panel" style="margin-top: 20px;" id="chess-chat-root"></div>

    <!-- Chess Coach Chat Component -->
    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // Chess coaching prompts
        const CHESS_PROMPTS = {
            moveAnalysis: `You are a direct chess coach. Analyze move [X] in my game. Tell me:
1) What was wrong with it, 2) What I should have played,
3) The pattern I missed, and 4) Specific puzzles to practice.`,
            fullGameReview: `Act as a chess instructor providing comprehensive game analysis.
Identify my 3 biggest mistakes, explain what I should have done
at each moment, teach me the patterns, and give me a focused
improvement plan.`,
            positionAnalysis: `Be a direct chess coach. In this position [FEN], I played [move]
and lost advantage. Show me exactly what tactic I missed, explain
the pattern step-by-step, and assign specific practice.`,
            compare3Games: `Compare these 3 recent games and identify patterns in my play.
Create a summary table showing: Game (opponent), Color, Opening, Result, Blunders, Mistakes.
Analyze: 1) Common tactical weaknesses across games, 2) Opening patterns and deviations,
3) Where I'm losing advantage most often (opening/middlegame/endgame),
4) One focused improvement area based on recurring themes.
End with a Socratic question about a specific position to help me learn.`
        };

        // Available models
        const openaiModels = {
            'GPT-4o': 'gpt-4o',
            'GPT-4o Mini': 'gpt-4o-mini',
            'GPT-4 Turbo': 'gpt-4-turbo',
            'GPT-3.5 Turbo': 'gpt-3.5-turbo',
            'o1': 'o1',
            'o1 Mini': 'o1-mini',
        };

        const anthropicModels = {
            'Claude 3.5 Haiku': 'claude-3-5-haiku-20241022',
            'Claude 3.5 Sonnet': 'claude-3-5-sonnet-20241022',
            'Claude Sonnet 4': 'claude-sonnet-4-20250514',
            'Claude Opus 4.5': 'claude-opus-4-5-20251101',
        };

        function ChessChat() {
            // State
            const [aiProvider, setAiProvider] = useState('ChatGPT');
            const [apiKey, setApiKey] = useState('');
            const [selectedModel, setSelectedModel] = useState('gpt-4o-mini');
            const [useSharedKey, setUseSharedKey] = useState(false);
            const [accessCode, setAccessCode] = useState('');
            const [messages, setMessages] = useState([]);
            const [inputValue, setInputValue] = useState('');
            const [isLoading, setIsLoading] = useState(false);

            // Batch analysis state
            const [batchUsername, setBatchUsername] = useState('');
            const [isBatchAnalyzing, setIsBatchAnalyzing] = useState(false);
            const [batchProgress, setBatchProgress] = useState(0);
            const [batchStatus, setBatchStatus] = useState('');

            const chatContainerRef = useRef(null);
            const models = aiProvider === 'ChatGPT' ? openaiModels : anthropicModels;

            // Reset model when provider changes
            useEffect(() => {
                if (aiProvider === 'ChatGPT') {
                    setSelectedModel('gpt-4o-mini');
                } else {
                    setSelectedModel('claude-3-5-haiku-20241022');
                }
            }, [aiProvider]);

            // Auto-scroll to bottom when new messages arrive
            useEffect(() => {
                if (chatContainerRef.current) {
                    chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
                }
            }, [messages]);

            // Load analysis report into textarea
            const loadAnalysisReport = () => {
                // Check multiple sources for report text:
                // 1. window.analysisReportRawText - from running analysis
                // 2. window.studyReportRawText - from loading via clipboard/file
                // 3. DOM element - the actual displayed report text
                let reportText = window.analysisReportRawText;

                if (!reportText || !reportText.trim()) {
                    reportText = window.studyReportRawText;
                }

                if (!reportText || !reportText.trim()) {
                    const reportElement = document.getElementById('analysisReportText');
                    if (reportElement && reportElement.textContent && reportElement.textContent !== 'Loading report...') {
                        reportText = reportElement.textContent;
                    }
                }

                if (reportText && reportText.trim()) {
                    setInputValue(prev => prev + (prev ? '\n\n' : '') + reportText);
                } else {
                    alert('No analysis report loaded. Please analyze a game first or load a report from clipboard.');
                }
            };

            // Append prompt to textarea
            const appendPrompt = (promptKey) => {
                const prompt = CHESS_PROMPTS[promptKey];
                setInputValue(prev => prev + (prev ? '\n\n' : '') + prompt);
            };

            // Analyze last 3 games for a username - uses existing analyzeGame() function
            const analyzeLast3Games = async () => {
                if (!batchUsername.trim()) {
                    alert('Please enter a Chess.com username');
                    return;
                }

                setIsBatchAnalyzing(true);
                setBatchProgress(0);
                setBatchStatus('Fetching games...');
                let allReports = '';

                try {
                    const username = batchUsername.trim().toLowerCase();
                    const now = new Date();
                    const year = now.getFullYear();
                    const month = String(now.getMonth() + 1).padStart(2, '0');

                    setBatchProgress(2);
                    let response = await fetch(`https://api.chess.com/pub/player/${username}/games/${year}/${month}`);
                    let gamesData;

                    if (!response.ok) {
                        const prevMonth = now.getMonth() === 0 ? 12 : now.getMonth();
                        const prevYear = now.getMonth() === 0 ? year - 1 : year;
                        response = await fetch(`https://api.chess.com/pub/player/${username}/games/${prevYear}/${String(prevMonth).padStart(2, '0')}`);
                        if (!response.ok) throw new Error('Could not fetch games. Check username.');
                    }
                    gamesData = await response.json();

                    if (!gamesData.games || gamesData.games.length === 0) {
                        throw new Error('No games found.');
                    }

                    const recentGames = gamesData.games
                        .filter(g => g.pgn)
                        .sort((a, b) => (b.end_time || 0) - (a.end_time || 0))
                        .slice(0, 3);

                    if (recentGames.length === 0) throw new Error('No games with PGN found.');

                    setBatchProgress(5);
                    setBatchStatus(`Found ${recentGames.length} games. Starting analysis...`);
                    const totalGames = recentGames.length;

                    // Helper to format game date
                    const formatDate = (timestamp) => {
                        if (!timestamp) return '';
                        const d = new Date(timestamp * 1000);
                        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    };

                    // Analyze each game using existing analyzeGame() function
                    for (let i = 0; i < totalGames; i++) {
                        const game = recentGames[i];
                        const gameNum = i + 1;

                        const white = game.white;
                        const black = game.black;
                        const whiteUsername = white.username || 'Unknown';
                        const blackUsername = black.username || 'Unknown';
                        const isWhite = whiteUsername.toLowerCase() === username;
                        const opponent = isWhite ? blackUsername : whiteUsername;
                        const playerColor = isWhite ? 'White' : 'Black';
                        const timeClass = game.time_class || 'unknown';
                        const gameDate = formatDate(game.end_time);

                        let result = 'Draw';
                        if (white.result === 'win') result = isWhite ? 'Win' : 'Loss';
                        else if (black.result === 'win') result = isWhite ? 'Loss' : 'Win';

                        setBatchStatus(`Analyzing game ${gameNum}/${totalGames}: vs ${opponent}...`);
                        setBatchProgress(5 + (i * 30));

                        // Extract clean PGN moves
                        let pgn = game.pgn || '';
                        const pgnLines = pgn.split('\n');
                        const moveLines = pgnLines.filter(line => !line.startsWith('[') && line.trim());
                        pgn = moveLines.join(' ').trim();
                        pgn = pgn.replace(/\{[^}]*\}/g, '').replace(/\$\d+/g, '').replace(/\s+/g, ' ').trim();

                        // Set up game data for the existing analysis system
                        const label = `Game ${gameNum}: vs ${opponent} (${result} as ${playerColor}) - ${timeClass} - ${gameDate}`;

                        // Store in fetchedGames for metadata access
                        window.fetchedGames = window.fetchedGames || {};
                        window.fetchedGames[label] = {
                            pgn: pgn,
                            fullPgn: game.pgn,
                            metadata: {
                                white: whiteUsername,
                                black: blackUsername,
                                white_rating: white.rating || '?',
                                black_rating: black.rating || '?',
                                result: result,
                                time_class: timeClass,
                                time_control: game.time_control || '',
                                url: game.url || '',
                                end_time: game.end_time
                            }
                        };

                        // Update the dropdown and select this game
                        const gameDropdown = document.getElementById('game-dropdown');
                        if (gameDropdown) {
                            // Add option if not exists
                            let optionExists = Array.from(gameDropdown.options).some(o => o.value === label);
                            if (!optionExists) {
                                const option = document.createElement('option');
                                option.value = label;
                                option.textContent = label;
                                gameDropdown.appendChild(option);
                            }
                            gameDropdown.value = label;
                        }

                        // Set PGN in the input
                        const pgnInput = document.getElementById('pgnInput');
                        if (pgnInput) {
                            pgnInput.value = pgn;
                        }

                        // Clear previous report
                        window.analysisReportRawText = null;

                        // Run the existing analyzeGame function
                        await analyzeGame();

                        // Wait a moment for report to be generated
                        await new Promise(resolve => setTimeout(resolve, 100));

                        // Capture the report
                        const report = window.analysisReportRawText;
                        if (report) {
                            allReports += `\n${'='.repeat(60)}\n`;
                            allReports += `GAME ${gameNum} of 3\n`;
                            allReports += `${'='.repeat(60)}\n`;
                            allReports += report;
                        }

                        window.batch3GamesReports = allReports;
                        setBatchProgress(5 + ((i + 1) * 30));
                    }

                    // Done - load into chat
                    setBatchProgress(100);
                    setBatchStatus('Done! Loading into chat...');
                    const fullPrompt = CHESS_PROMPTS.compare3Games + '\n' + allReports;
                    setInputValue(fullPrompt);

                } catch (error) {
                    setBatchStatus(`Error: ${error.message}`);
                } finally {
                    setTimeout(() => {
                        setIsBatchAnalyzing(false);
                        setBatchProgress(0);
                        setBatchStatus('');
                    }, 1500);
                }
            };

            // Send message
            const sendMessage = async () => {
                const needsApiKey = !(aiProvider === 'ChatGPT' && useSharedKey);
                if (!inputValue.trim()) return;
                if (needsApiKey && !apiKey) {
                    alert(`Please enter your ${aiProvider === 'ChatGPT' ? 'OpenAI' : 'Anthropic'} API key`);
                    return;
                }

                const userMessage = { role: 'user', content: inputValue };
                const newMessages = [...messages, userMessage];
                setMessages(newMessages);
                setInputValue('');
                setIsLoading(true);

                try {
                    let assistantMessage;

                    if (aiProvider === 'ChatGPT') {
                        const openaiMessages = newMessages.map(m => ({ role: m.role, content: m.content }));
                        const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';

                        if (isLocalhost && !useSharedKey) {
                            // Local development: call OpenAI directly
                            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${apiKey}`,
                                },
                                body: JSON.stringify({
                                    model: selectedModel,
                                    max_tokens: 4096,
                                    messages: openaiMessages,
                                }),
                            });

                            if (!response.ok) {
                                const errorData = await response.json();
                                throw new Error(errorData.error?.message || 'API request failed');
                            }

                            const data = await response.json();
                            assistantMessage = {
                                role: 'assistant',
                                content: data.choices[0].message.content,
                            };
                        } else {
                            // Production (Vercel): use backend API
                            console.log('Calling /api/chat with:', { useSharedKey, hasAccessCode: !!accessCode, model: selectedModel });
                            const response = await fetch('/api/chat', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    messages: openaiMessages,
                                    model: selectedModel,
                                    userApiKey: useSharedKey ? null : apiKey,
                                    accessCode: useSharedKey ? accessCode : null,
                                }),
                            });

                            console.log('Response status:', response.status);
                            const responseText = await response.text();
                            console.log('Response text:', responseText);

                            if (!response.ok) {
                                let errorMsg = 'API request failed';
                                // Check if running locally without Vercel API
                                const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                                if (isLocalhost && (response.status === 404 || responseText.includes('File not found'))) {
                                    errorMsg = "Stanley's shared key requires Vercel deployment. Use your own API key for local testing, or deploy to Vercel.";
                                } else {
                                    try {
                                        const errorData = JSON.parse(responseText);
                                        errorMsg = errorData.error || errorMsg;
                                    } catch (e) {
                                        errorMsg = responseText || `HTTP ${response.status}`;
                                    }
                                }
                                throw new Error(errorMsg);
                            }

                            const data = JSON.parse(responseText);
                            assistantMessage = {
                                role: 'assistant',
                                content: data.content,
                            };
                        }
                    } else {
                        // Anthropic API call
                        const response = await fetch('https://api.anthropic.com/v1/messages', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-api-key': apiKey,
                                'anthropic-version': '2023-06-01',
                                'anthropic-dangerous-direct-browser-access': 'true',
                            },
                            body: JSON.stringify({
                                model: selectedModel,
                                max_tokens: 4096,
                                messages: newMessages.map(m => ({ role: m.role, content: m.content })),
                            }),
                        });

                        if (!response.ok) {
                            const errorData = await response.json();
                            throw new Error(errorData.error?.message || 'API request failed');
                        }

                        const data = await response.json();
                        assistantMessage = {
                            role: 'assistant',
                            content: data.content[0].text,
                        };
                    }

                    setMessages([...newMessages, assistantMessage]);
                } catch (error) {
                    console.error('Error:', error);
                    setMessages([...newMessages, {
                        role: 'assistant',
                        content: `Error: ${error.message}`,
                    }]);
                } finally {
                    setIsLoading(false);
                }
            };

            // Handle Enter key
            const handleKeyPress = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            };

            // Copy chat
            const copyChat = async () => {
                if (messages.length === 0) {
                    alert('No messages to copy');
                    return;
                }
                const chatText = messages
                    .map(msg => `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.content}`)
                    .join('\n\n');
                try {
                    await navigator.clipboard.writeText(chatText);
                    alert('Chat copied to clipboard!');
                } catch (err) {
                    alert('Failed to copy chat');
                }
            };

            // Styles
            const styles = {
                navbar: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '12px',
                    flexWrap: 'wrap',
                    marginBottom: '12px',
                    padding: '10px',
                    background: '#0f3460',
                    borderRadius: '8px',
                },
                providerToggle: {
                    display: 'flex',
                    gap: '0',
                    borderRadius: '6px',
                    overflow: 'hidden',
                },
                providerBtn: {
                    padding: '8px 14px',
                    border: 'none',
                    fontSize: '13px',
                    fontWeight: '500',
                    background: '#1a1a2e',
                    color: '#888',
                    cursor: 'pointer',
                },
                providerBtnActive: {
                    background: '#00d4ff',
                    color: '#1a1a2e',
                },
                input: {
                    padding: '8px 12px',
                    borderRadius: '6px',
                    border: '1px solid #1a1a2e',
                    fontSize: '13px',
                    background: '#1a1a2e',
                    color: '#eee',
                    minWidth: '150px',
                },
                select: {
                    padding: '8px 12px',
                    borderRadius: '6px',
                    border: '1px solid #1a1a2e',
                    fontSize: '13px',
                    background: '#1a1a2e',
                    color: '#eee',
                    cursor: 'pointer',
                },
                button: {
                    padding: '8px 14px',
                    borderRadius: '6px',
                    border: 'none',
                    fontSize: '13px',
                    fontWeight: '500',
                    cursor: 'pointer',
                },
                promptButtons: {
                    display: 'flex',
                    gap: '8px',
                    flexWrap: 'wrap',
                    marginBottom: '12px',
                },
                chatMessages: {
                    maxHeight: '400px',
                    overflowY: 'auto',
                    background: '#0f3460',
                    borderRadius: '8px',
                    padding: '15px',
                    marginBottom: '12px',
                },
                message: {
                    padding: '10px 14px',
                    borderRadius: '8px',
                    marginBottom: '10px',
                    maxWidth: '85%',
                },
                userMessage: {
                    background: '#00d4ff',
                    color: '#1a1a2e',
                    marginLeft: 'auto',
                },
                assistantMessage: {
                    background: '#1a1a2e',
                    color: '#eee',
                },
                inputArea: {
                    display: 'flex',
                    gap: '10px',
                },
                textarea: {
                    flex: 1,
                    padding: '12px',
                    borderRadius: '8px',
                    border: '1px solid #0f3460',
                    background: '#0f3460',
                    color: '#eee',
                    fontSize: '14px',
                    resize: 'vertical',
                    minHeight: '60px',
                    maxHeight: '200px',
                    fontFamily: 'inherit',
                },
                emptyState: {
                    textAlign: 'center',
                    color: '#888',
                    padding: '40px 20px',
                },
            };

            return (
                <div>
                    <h2 style={{ color: '#00d4ff', marginTop: 0 }}>Chess Coach Chat</h2>

                    {/* Navbar-style controls */}
                    <div style={styles.navbar}>
                        {/* Provider Toggle */}
                        <div style={styles.providerToggle}>
                            <button
                                onClick={() => setAiProvider('ChatGPT')}
                                style={{
                                    ...styles.providerBtn,
                                    ...(aiProvider === 'ChatGPT' ? styles.providerBtnActive : {}),
                                }}
                            >
                                ChatGPT
                            </button>
                            <button
                                onClick={() => setAiProvider('Anthropic')}
                                style={{
                                    ...styles.providerBtn,
                                    ...(aiProvider === 'Anthropic' ? styles.providerBtnActive : {}),
                                }}
                            >
                                Claude
                            </button>
                        </div>

                        {/* API Key */}
                        <input
                            type="password"
                            value={apiKey}
                            onChange={(e) => setApiKey(e.target.value)}
                            placeholder={aiProvider === 'ChatGPT' ? 'OpenAI API Key' : 'Anthropic API Key'}
                            style={styles.input}
                        />

                        {/* Use Stanley's Key - ChatGPT only */}
                        {aiProvider === 'ChatGPT' && (
                            <button
                                onClick={() => {
                                    const code = prompt("Enter access code for Stanley's key:");
                                    if (code) {
                                        setAccessCode(code);
                                        setUseSharedKey(true);
                                        setApiKey('');
                                    }
                                }}
                                style={{
                                    ...styles.button,
                                    background: useSharedKey ? '#51cf66' : '#6c757d',
                                    color: 'white',
                                }}
                            >
                                {useSharedKey ? "‚úì Using Stanley's Key" : "Use Stanley's Key"}
                            </button>
                        )}

                        {/* Model Selection */}
                        <select
                            value={selectedModel}
                            onChange={(e) => setSelectedModel(e.target.value)}
                            style={styles.select}
                        >
                            {Object.entries(models).map(([name, id]) => (
                                <option key={id} value={id}>{name}</option>
                            ))}
                        </select>

                        {/* Load Analysis Report */}
                        <button
                            onClick={loadAnalysisReport}
                            style={{ ...styles.button, background: '#fd7e14', color: 'white' }}
                        >
                            üìã Load Analysis Report
                        </button>

                        {/* Copy Chat */}
                        <button
                            onClick={copyChat}
                            style={{ ...styles.button, background: '#28a745', color: 'white' }}
                        >
                            Copy Chat
                        </button>

                        {/* Clear Chat */}
                        <button
                            onClick={() => setMessages([])}
                            style={{ ...styles.button, background: '#6c757d', color: 'white' }}
                        >
                            Clear Chat
                        </button>
                    </div>

                    {/* Prompt Buttons */}
                    <div style={{ marginBottom: '12px' }}>
                        <div style={{ fontSize: '12px', color: '#888', marginBottom: '6px' }}>
                            Prompts to attach to chatbox:
                        </div>
                        <div style={styles.promptButtons}>
                            <button
                                onClick={() => appendPrompt('moveAnalysis')}
                                style={{ ...styles.button, background: '#17a2b8', color: 'white' }}
                            >
                                Move Analysis
                            </button>
                            <button
                                onClick={() => appendPrompt('fullGameReview')}
                                style={{ ...styles.button, background: '#6f42c1', color: 'white' }}
                            >
                                Full Game Review
                            </button>
                            <button
                                onClick={() => appendPrompt('positionAnalysis')}
                                style={{ ...styles.button, background: '#dc3545', color: 'white' }}
                            >
                                Position Analysis
                            </button>
                        </div>
                    </div>

                    {/* Batch Analysis Section */}
                    <div style={{ background: '#0a1628', padding: '12px', borderRadius: '8px', marginBottom: '12px' }}>
                        <div style={{ display: 'flex', gap: '8px', alignItems: 'center', flexWrap: 'wrap' }}>
                            <input
                                type="text"
                                value={batchUsername}
                                onChange={(e) => setBatchUsername(e.target.value)}
                                placeholder="Chess.com username"
                                style={{ ...styles.input, flex: '1', minWidth: '150px' }}
                                disabled={isBatchAnalyzing}
                            />
                            <button
                                onClick={analyzeLast3Games}
                                disabled={isBatchAnalyzing || !batchUsername.trim()}
                                style={{
                                    ...styles.button,
                                    background: isBatchAnalyzing ? '#555' : '#e83e8c',
                                    color: 'white',
                                    opacity: isBatchAnalyzing || !batchUsername.trim() ? 0.7 : 1
                                }}
                            >
                                {isBatchAnalyzing ? 'Analyzing...' : 'Analyze Last 3 Games'}
                            </button>
                        </div>
                        {(isBatchAnalyzing || batchStatus) && (
                            <div style={{ marginTop: '10px' }}>
                                <div style={{
                                    background: '#1a1a2e',
                                    borderRadius: '4px',
                                    height: '8px',
                                    overflow: 'hidden'
                                }}>
                                    <div style={{
                                        background: 'linear-gradient(90deg, #e83e8c, #00d4ff)',
                                        height: '100%',
                                        width: `${batchProgress}%`,
                                        transition: 'width 0.3s ease'
                                    }} />
                                </div>
                                <div style={{ fontSize: '12px', color: '#888', marginTop: '6px' }}>
                                    {batchStatus}
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Chat Messages */}
                    <div ref={chatContainerRef} style={styles.chatMessages}>
                        {messages.length === 0 ? (
                            <div style={styles.emptyState}>
                                <p>Ask your chess coach a question!</p>
                                <p style={{ fontSize: '13px' }}>
                                    Use the prompt buttons above, or load your analysis report and ask for feedback.
                                </p>
                            </div>
                        ) : (
                            messages.map((msg, index) => (
                                <div
                                    key={index}
                                    style={{
                                        ...styles.message,
                                        ...(msg.role === 'user' ? styles.userMessage : styles.assistantMessage),
                                    }}
                                >
                                    <div style={{ fontSize: '11px', fontWeight: 'bold', marginBottom: '4px', opacity: 0.7 }}>
                                        {msg.role === 'user' ? 'You' : (aiProvider === 'ChatGPT' ? 'ChatGPT' : 'Claude')}
                                    </div>
                                    {msg.role === 'assistant' ? (
                                        <div
                                            className="markdown-content"
                                            style={{ lineHeight: '1.6' }}
                                            dangerouslySetInnerHTML={{ __html: marked.parse(msg.content) }}
                                        />
                                    ) : (
                                        <div style={{ whiteSpace: 'pre-wrap', lineHeight: '1.5' }}>
                                            {msg.content}
                                        </div>
                                    )}
                                </div>
                            ))
                        )}
                        {isLoading && (
                            <div style={{ ...styles.message, ...styles.assistantMessage }}>
                                <div style={{ fontSize: '11px', fontWeight: 'bold', marginBottom: '4px', opacity: 0.7 }}>
                                    {aiProvider === 'ChatGPT' ? 'ChatGPT' : 'Claude'}
                                </div>
                                <div>Thinking...</div>
                            </div>
                        )}
                    </div>

                    {/* Input Area */}
                    <div style={styles.inputArea}>
                        <textarea
                            value={inputValue}
                            onChange={(e) => setInputValue(e.target.value)}
                            onKeyPress={handleKeyPress}
                            placeholder="Type your message... (Enter to send, Shift+Enter for new line)"
                            style={styles.textarea}
                            disabled={isLoading}
                        />
                        <button
                            onClick={sendMessage}
                            disabled={isLoading || !inputValue.trim()}
                            style={{
                                ...styles.button,
                                background: '#00d4ff',
                                color: '#1a1a2e',
                                alignSelf: 'flex-end',
                                padding: '12px 24px',
                                opacity: isLoading || !inputValue.trim() ? 0.6 : 1,
                            }}
                        >
                            Send
                        </button>
                    </div>
                </div>
            );
        }

        // Render the component
        const root = ReactDOM.createRoot(document.getElementById('chess-chat-root'));
        root.render(<ChessChat />);
    </script>
</body>
</html>
